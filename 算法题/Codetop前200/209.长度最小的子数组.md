# 209. 长度最小的子数组

### 思路（<font style="color:#DF2A3F;">滑动窗口，达到条件后收缩窗口（用 while 是一直收缩，找到符合条件长度最小子数组</font>））
这个问题是一个典型的“滑动窗口”问题，目标是通过滑动窗口的方式寻找一个子数组，使得其和大于等于 `target` 且长度最小。

#### 思路：
1. **滑动窗口**：我们使用两个指针 `left` 和 `right` 来表示当前的窗口。`right` 用于扩展窗口，`left` 用于收缩窗口。
2. **窗口的总和**：每次扩展 `right` 指针时，我们将窗口中的元素加到当前的总和上。当窗口中的总和大于等于 `target` 时，我们尝试收缩窗口（即移动 `left` 指针）以找出满足条件的最小子数组。
3. **更新最小长度**：每次当窗口总和满足条件时，记录当前子数组的长度，并更新最小长度。
4. **边界条件**：如果最后没有找到符合条件的子数组，返回 `0`。

#### 步骤：
1. 初始化 `left = 0` 和 `sum = 0`。
2. 遍历数组，逐步扩展窗口（`right` 指针逐步向右移动），将元素加入 `sum`。
3. 每次 `sum` 大于等于 `target` 时，尝试移动 `left` 指针，使窗口尽量缩小，同时更新最小子数组长度。
4. 最终返回最小子数组的长度，如果不存在符合条件的子数组，则返回 `0`。

### Java 代码
```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0, right = 0;  // 初始化左右指针
        int sum = 0, minlen = Integer.MAX_VALUE;  // 初始化和与最小长度

        while (right < nums.length) {  // 遍历数组
            sum += nums[right];  // 右指针扩展，加入当前元素到窗口和

            // 当窗口的和大于等于target时，开始收缩窗口
            while (sum >= target) {
                minlen = Math.min(minlen, right - left + 1);  // 更新最小子数组长度
                sum -= nums[left];  // 收缩窗口，减去左指针处的元素
                left++;  // 左指针右移，缩小窗口
            }

            right++;  // 右指针继续向右移动，扩展窗口
        }

        // 如果minlen没有更新过，说明没有符合条件的子数组，返回0
        return minlen == Integer.MAX_VALUE ? 0 : minlen;
    }
}

```

### 代码解释：
1. **变量初始化**：
    - `left`：左指针，初始位置为 `0`。
    - `sum`：当前窗口的元素和，初始为 `0`。
    - `minLength`：记录满足条件的最小子数组长度，初始为一个很大的数，表示没有找到子数组时的状态。
2. **遍历数组**：
    - 使用 `right` 指针遍历数组，逐步扩展窗口。
    - 每次扩展窗口时，将 `right` 指向的元素加入 `sum`。
    - 当 `sum` 大于等于 `target` 时，尝试收缩窗口，即通过移动 `left` 指针来减小窗口大小，并更新 `minLength`。
3. **返回结果**：
    - 如果 `minLength` 被更新过，返回最小长度；否则，返回 `0`，表示没有符合条件的子数组。

### 时间复杂度分析：
+ **时间复杂度**：`O(n)`，其中 `n` 是数组的长度。每个元素最多被访问两次（一次在 `right` 扩展窗口时，另一次在 `left` 收缩窗口时）。
+ **空间复杂度**：`O(1)`，只使用了常数空间。

### 


> 更新: 2025-05-17 16:47:37  
> 原文: <https://www.yuque.com/neumx/ko4psh/rf1f6rah8o3oi82i>