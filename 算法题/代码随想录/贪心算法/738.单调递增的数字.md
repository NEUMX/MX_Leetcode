# 738. 单调递增的数字

### 解题思路
### 解题思路
1. **将数字转为字符数组**：便于逐位操作。
2. **从高位到低位遍历**：如果发现某一位比它后面的位大，就需要调整：
    - 将这一位减 1。
    - 将这一位之后的所有位变成 9。
3. **确保前面的数字仍然单调递增**：如果调整后前面的位不再满足单调递增，则继续向前调整。
4. **最终转换回数字输出**。

---

```java
class Solution {
    public int monotoneIncreasingDigits(int n) {
        // 将数字转换为字符数组，方便逐位处理
        char[] s = String.valueOf(n).toCharArray();
        int len = s.length; // 数字的长度
        int pos = len; // 记录需要调整的位置，初始化为数字的长度

        // 从右到左遍历字符数组，找到第一个不满足单调递增的位置
        for (int i = len - 1; i > 0; i--) {
            // 如果前一位大于当前位，说明不满足单调递增
            if (s[i - 1] > s[i]) {
                pos = i; // 记录需要调整的位置
                s[i - 1]--; // 将前一位减 1，使其小于当前位
            }
        }

        // 从 pos 开始，将后面的所有位设置为 '9'，以确保数字最大且单调递增
        for (int i = pos; i < len; i++) {
            s[i] = '9';
        }

        // 将字符数组转换回数字并返回
        return Integer.parseInt(new String(s));
    }
}
```

### **复杂度分析**
1. **时间复杂度**：
    - 遍历字符数组两次，时间复杂度为 `O(n)`，其中 `n` 是数字的位数。
2. **空间复杂度**：
    - 使用了字符数组 `s`，空间复杂度为 `O(n)`。







> 更新: 2025-01-12 22:35:53  
> 原文: <https://www.yuque.com/neumx/ko4psh/ndkclqvuwtd2hcfs>