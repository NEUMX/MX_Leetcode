# 122. 买卖股票的最佳时机 II

### 思路（<font style="color:#DF2A3F;">不限制买卖次数，所以贪心就是，只要价格比前一天高，就卖出去然后累加</font>）
在这个问题中，我们可以采用以下策略：

+ **只要今天的价格比昨天高，就进行买卖操作**。也就是说，如果 `prices[i] > prices[i-1]`，我们就在第 `i-1` 天买入，第 `i` 天卖出，获得利润 `prices[i] - prices[i-1]`。
+ **累加所有这样的利润**，最终得到的总和就是最大利润。

---

```java
public class Solution {
    // 计算股票的最大利润
    public int maxProfit(int[] prices) {
        int maxProfit = 0; // 初始化最大利润为0

        // 遍历价格数组，从第二天开始
        for (int i = 1; i < prices.length; i++) {
            // 如果当前价格比前一天高，计算利润并累加到maxProfit
            if (prices[i] > prices[i - 1]) {
                maxProfit += prices[i] - prices[i - 1];
            }
        }

        // 返回计算得到的最大利润
        return maxProfit;
    }
}
```

### 时间复杂度与空间复杂度
#### 时间复杂度
遍历数组一次，时间复杂度为 O(n)。

#### 空间复杂度
空间复杂度为 O(1)。

---

## 动规解法
### 思路
我们定义两个状态：

1. **持有股票（**`**dp[i][1]**`**）**：第 `i` 天结束时持有股票的最大收益。
2. **不持有股票（**`**dp[i][0]**`**）**：第 `i` 天结束时不持有股票的最大收益。

**状态转移方程**：

1. `dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])`
    - 第 `i` 天不持有股票，可能来自：
        * 第 `i-1` 天不持有股票，继续保持 `dp[i-1][0]`。
        * 第 `i-1` 天持有股票并在第 `i` 天卖出，收益为 `dp[i-1][1] + prices[i]`。
2. `dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])`
    - 第 `i` 天持有股票，可能来自：
        * 第 `i-1` 天持有股票，继续保持 `dp[i-1][1]`。
        * 第 `i-1` 天不持有股票并在第 `i` 天买入，收益为 `dp[i-1][0] - prices[i]`。

**初始状态**：

+ `dp[0][0] = 0`：第 0 天不持有股票，收益为 0。
+ `dp[0][1] = -prices[0]`：第 0 天持有股票，收益为负数。

**最终结果**：

+ 最大收益是 `dp[n-1][0]`，即最后一天不持有股票的最大收益。（**<font style="color:#DF2A3F;">因为最后一天不持有股票说明卖出去了，那肯定有利润，不然最后一天还持有股票卖不出去</font>**了）



```java
public class MaxProfit {
    // 计算股票的最大利润（支持多次买卖）
    public static int maxProfit(int[] prices) {
        // 如果价格数组为空或长度为0，直接返回0
        if (prices == null || prices.length == 0) {
            return 0;
        }

        int n = prices.length; // 价格数组的长度
        int[][] dp = new int[n][2]; // 定义动态规划数组，dp[i][0]表示第i天不持有股票的最大利润，dp[i][1]表示第i天持有股票的最大利润

        // 初始化
        dp[0][0] = 0; // 第一天不持有股票，利润为0
        dp[0][1] = -prices[0]; // 第一天持有股票，利润为 -prices[0]（因为需要花钱买入）

        // 动态规划递推
        for (int i = 1; i < n; i++) {
            // 第i天不持有股票的最大利润：
            // 1. 前一天也不持有股票，今天什么也不做
            // 2. 前一天持有股票，今天卖出股票
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);

            // 第i天持有股票的最大利润：
            // 1. 前一天也持有股票，今天什么也不做
            // 2. 前一天不持有股票，今天买入股票
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }

        // 最终返回最后一天不持有股票的最大利润
        return dp[n - 1][0];
    }
}
```

### 时间复杂度和空间复杂度
+ **时间复杂度**：on，遍历价格数组一次。
+ **空间复杂度**：
    - 初始版本：O(n)，使用二维数组存储所有状态。

### 优化版，空间复杂度变成 O1
```java
public class MaxProfit {
    // 计算股票的最大利润（支持多次买卖）
    public static int maxProfit(int[] prices) {
        // 如果价格数组为空或长度为0，直接返回0
        if (prices == null || prices.length == 0) {
            return 0;
        }

        // 初始化动态规划状态
        int dp0 = 0; // 当前不持有股票的最大收益，初始化为0（第一天不持有股票）
        int dp1 = -prices[0]; // 当前持有股票的最大收益，初始化为 -prices[0]（第一天买入股票）

        // 遍历价格数组，从第二天开始
        for (int i = 1; i < prices.length; i++) {
            // 暂存上一轮的 dp0，用于更新 dp1
            int temp = dp0;

            // 更新 dp0：当前不持有股票的最大收益
            // 有两种可能：
            // 1. 前一天也不持有股票，今天什么也不做
            // 2. 前一天持有股票，今天卖出股票
            dp0 = Math.max(dp0, dp1 + prices[i]);

            // 更新 dp1：当前持有股票的最大收益
            // 有两种可能：
            // 1. 前一天也持有股票，今天什么也不做
            // 2. 前一天不持有股票，今天买入股票
            dp1 = Math.max(dp1, temp - prices[i]);
        }

        // 返回最后一天不持有股票的最大利润
        return dp0;
    }
}
```



> 更新: 2025-01-05 22:00:53  
> 原文: <https://www.yuque.com/neumx/ko4psh/du067uzsf8b2x4dq>