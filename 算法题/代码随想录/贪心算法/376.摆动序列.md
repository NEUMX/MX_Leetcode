# 376. 摆动序列

### 思路（<font style="color:#DF2A3F;">贪心，记录当前当趋势发生变化时（从正变负或从负变正），摆动序列的长度加 1，最后取最大值</font>）
### 贪心策略
为了找到最长的摆动子序列，我们可以采用以下贪心策略：

1. **记录趋势变化**：
    - 遍历数组，记录相邻元素之间的差值趋势（正、负或零）。
    - 当趋势发生变化时（从正变负或从负变正），摆动序列的长度加 1。
2. **跳过不影响趋势的元素**：
    - 如果当前元素与上一个元素的差值为零，或者趋势没有变化，则跳过该元素。

### 算法步骤
1. 初始化两个变量：
    - `up`：表示当前趋势是上升的摆动序列长度。
    - `down`：表示当前趋势是下降的摆动序列长度。
2. 遍历数组：
    - 如果当前元素比前一个元素大，则更新 `up = down + 1`。
    - 如果当前元素比前一个元素小，则更新 `down = up + 1`。
3. 最终结果是 `max(up, down)`。
4. 在摆动序列问题中，返回 **上升状态 (**`**up**`**) 和下降状态 (**`**down**`**) 的最大值**，作为最长摆动子序列的长度，是因为在整个序列中，最终的最长摆动子序列可能是以下两种情况之一：
5. **以上升趋势结束的摆动子序列**：
    - 如果序列的最后一个摆动是“上升”的，说明最长摆动子序列是以 `up` 状态结束的。
    - 此时，`up` 表示这个子序列的长度。
6. **以下降趋势结束的摆动子序列**：
    - 如果序列的最后一个摆动是“下降”的，说明最长摆动子序列是以 `down` 状态结束的。
    - 此时，`down` 表示这个子序列的长度。

**最终结果**取决于这两种状态的最大值，因为最长摆动子序列可能以任何一种趋势结束。

---

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        // 如果数组长度小于 2，则直接返回数组长度
        // 因为 0 或 1 个元素的序列本身就是摆动序列
        if (nums.length < 2) {
            return nums.length;
        }

        // 初始化两个状态变量：
        // up 表示以当前元素为结尾，并且是上升趋势的最长摆动子序列长度
        int up = 1;
        // down 表示以当前元素为结尾，并且是下降趋势的最长摆动子序列长度
        int down = 1;

        // 从第二个元素开始遍历数组
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > nums[i - 1]) {
                // 如果当前元素大于前一个元素，形成上升趋势
                // 则更新 up 的长度为前一个下降趋势的长度加 1
                up = down + 1;
            } else if (nums[i] < nums[i - 1]) {
                // 如果当前元素小于前一个元素，形成下降趋势
                // 则更新 down 的长度为前一个上升趋势的长度加 1
                down = up + 1;
            }
            // 如果当前元素等于前一个元素，跳过，无需更新状态
        }

        // 返回上升和下降两种状态的最大值，即为最长摆动子序列的长度
        return Math.max(up, down);
    }
}

```

### 时间复杂度与空间复杂度
1. **时间复杂度**：`O(n)`，仅需遍历数组一次。
2. **空间复杂度**：`O(1)`，只需常量额外空间。

---

## 动规解法
### 动态规划解法思路
#### 定义状态
1. `up[i]`: 表示以第 `i` 个元素结尾的最长摆动子序列，且最后一个差值为正数。
2. `down[i]`: 表示以第 `i` 个元素结尾的最长摆动子序列，且最后一个差值为负数。

#### 状态转移方程
1. 如果 `nums[i] > nums[i-1]`，即当前元素大于前一个元素：
    - `up[i] = down[i-1] + 1`，当前元素形成上升趋势。
    - `down[i] = down[i-1]`，下降序列保持不变。
2. 如果 `nums[i] < nums[i-1]`，即当前元素小于前一个元素：
    - `down[i] = up[i-1] + 1`，当前元素形成下降趋势。
    - `up[i] = up[i-1]`，上升序列保持不变。
3. 如果 `nums[i] == nums[i-1]`：
    - `up[i] = up[i-1]`
    - `down[i] = down[i-1]`

#### 最终结果
`max(up[n-1], down[n-1])`，即为最长摆动子序列的长度。

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        // 如果数组长度小于 2，直接返回数组长度
        // 因为只有一个或零个元素的序列本身就是摆动序列
        if (nums.length < 2) {
            return nums.length;
        }

        // 定义动态规划数组
        // up[i]: 以 nums[i] 为结尾，并且最后一个差值为正数的最长摆动子序列长度
        int[] up = new int[nums.length];
        // down[i]: 以 nums[i] 为结尾，并且最后一个差值为负数的最长摆动子序列长度
        int[] down = new int[nums.length];

        // 初始状态
        // 第一个元素本身可以构成一个摆动序列，长度为 1
        up[0] = 1;
        down[0] = 1;

        // 动态规划过程
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > nums[i - 1]) {
                // 当前元素大于前一个元素，形成上升摆动
                // 此时以 nums[i] 结尾的上升摆动序列长度是前一个下降摆动序列长度加 1
                up[i] = down[i - 1] + 1;
                // 下降摆动序列的长度保持不变
                down[i] = down[i - 1];
            } else if (nums[i] < nums[i - 1]) {
                // 当前元素小于前一个元素，形成下降摆动
                // 此时以 nums[i] 结尾的下降摆动序列长度是前一个上升摆动序列长度加 1
                down[i] = up[i - 1] + 1;
                // 上升摆动序列的长度保持不变
                up[i] = up[i - 1];
            } else {
                // 当前元素等于前一个元素，不形成任何摆动
                // 保持上升和下降摆动序列的长度不变
                up[i] = up[i - 1];
                down[i] = down[i - 1];
            }
        }

        // 返回以最后一个元素结尾的摆动序列的最大长度
        // 即在上升摆动和下降摆动序列长度中取最大值
        return Math.max(up[nums.length - 1], down[nums.length - 1]);
    }
}

```

 原始动态规划版本：

+ 时间复杂度：**O(n)**
+ 空间复杂度：**O(n)**



> 更新: 2025-01-05 21:09:48  
> 原文: <https://www.yuque.com/neumx/ko4psh/xd53rit6y3bwt1cq>