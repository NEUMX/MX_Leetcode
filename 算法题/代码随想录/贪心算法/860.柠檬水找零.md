# 860. 柠檬水找零

### 思路（<font style="color:#DF2A3F;">维护五美元和十美元变量，然后模拟找钱过程</font>。）
### 们可以通过模拟交易过程来解决问题。根据题目要求：
1. 每位顾客付款后，我们需要找零，且必须按照最优方式找零（优先用大额钞票）。
2. 我们维护两个变量：
    - `five`：记录手头 5 美元钞票的数量。
    - `ten`：记录手头 10 美元钞票的数量。

#### 处理逻辑
+ 如果顾客支付 5 美元，直接收下，`five` 加一。
+ 如果顾客支付 10 美元，必须找零 5 美元：
    - 如果 `five` 大于等于 1，减少 `five`，并增加 `ten`。
    - 否则无法找零，返回 `false`。
+ 如果顾客支付 20 美元，必须找零 15 美元：
    - 优先使用一张 10 美元和一张 5 美元（如果都有）。
    - 如果没有 10 美元，但有至少三张 5 美元，用三张 5 美元找零。
    - 如果无法满足以上条件，返回 `false`。

#### 返回值
如果可以完成所有交易，返回 `true`；否则返回 `false`。

---

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        // 初始化 5 美元和 10 美元钞票的数量
        int five = 0, ten = 0;

        // 遍历每一笔交易
        for (int bill : bills) {
            if (bill == 5) {
                // 收到 5 美元，直接增加 5 美元的数量
                five++;
            } else if (bill == 10) {
                // 收到 10 美元，需要找零 5 美元
                if (five > 0) {
                    five--; // 减少一张 5 美元
                    ten++;  // 增加一张 10 美元
                } else {
                    // 如果没有 5 美元可以找零，返回 false
                    return false;
                }
            } else if (bill == 20) {
                // 收到 20 美元，优先找零 10+5
                if (ten > 0 && five > 0) {
                    ten--; // 减少一张 10 美元
                    five--; // 减少一张 5 美元
                } else if (five >= 3) {
                    // 如果没有 10 美元，尝试用 5+5+5 找零
                    five -= 3; // 减少三张 5 美元
                } else {
                    // 如果无法找零，返回 false
                    return false;
                }
            }
        }

        // 如果所有交易都能成功完成，返回 true
        return true;
    }
}
```

### 时复杂度分析
+ **时间复杂度**：`O(n)`， 其中 n 是数组 `bills` 的长度，我们只遍历一次数组。  。
+ **空间复杂度**：`O(1)`，只使用了常数级别的额外空间。







> 更新: 2025-01-12 21:54:48  
> 原文: <https://www.yuque.com/neumx/ko4psh/fd5hb5ple597hev5>