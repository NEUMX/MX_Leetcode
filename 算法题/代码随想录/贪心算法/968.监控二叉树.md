# 968. 监控二叉树

### 解题思路
1. **后序遍历（自底向上）**：
    - 对于每个节点，判断是否需要安装摄像头。
    - 使用递归，分别检查左右子树的状态。
2. **节点状态分类**：
    - 每个节点有 3 种可能状态：
        1. **未被监控（0）**：当前节点未被监控，但其父节点需要考虑监控它。
        2. **被监控但无摄像头（1）**：当前节点被其子节点的摄像头监控，无需自己安装摄像头。
        3. **有摄像头（2）**：当前节点安装了摄像头。
1. **递归处理规则**：
    - 如果某一子节点未被监控（状态 0），当前节点必须安装摄像头（状态 2）。
    - 如果某一子节点有摄像头（状态 2），当前节点被监控（状态 1）。
    - 如果某一子节点被监控但无摄像头（状态 1），当前节点状态取决于其它节点状态。
2. **根节点处理**：
    - 如果根节点未被监控，必须安装摄像头。

---

```java
class Solution {
    private int cameraCount = 0; // 记录需要安装的摄像头数量

    public int minCameraCover(TreeNode root) {
        // 如果根节点未被监控，需要安装摄像头
        if (dfs(root) == 0) {
            cameraCount++;
        }
        return cameraCount; // 返回最终的摄像头数量
    }

    /**
     * 递归遍历树的每个节点，返回节点的状态
     * 返回值含义：
     * 0 = 未被监控
     * 1 = 被监控但无摄像头
     * 2 = 有摄像头
     */
    private int dfs(TreeNode node) {
        // 如果节点为空，视为已被监控（状态 1）
        if (node == null) {
            return 1;
        }

        // 递归处理左子树和右子树，获取它们的状态
        int left = dfs(node.left);
        int right = dfs(node.right);

        // 如果左子节点或右子节点未被监控（状态 0）
        if (left == 0 || right == 0) {
            // 当前节点需要安装摄像头
            cameraCount++; // 摄像头数量加 1
            return 2; // 返回状态 2（有摄像头）
        }

        // 如果左子节点或右子节点有摄像头（状态 2）
        if (left == 2 || right == 2) {
            // 当前节点被监控但无需安装摄像头
            return 1; // 返回状态 1（被监控但无摄像头）
        }

        // 如果左右子节点都被监控但无摄像头（状态 1）
        // 当前节点未被监控
        return 0; // 返回状态 0（未被监控）
    }
}
```

### 时复杂度分析
### **复杂度分析**
1. **时间复杂度**：
    - 每个节点只会被访问一次，时间复杂度为 `O(n)`，其中 `n` 是节点数量。
2. **空间复杂度**：
    - 递归调用栈的深度为树的高度，最坏情况下为 `O(n)`。







> 更新: 2025-01-12 22:39:42  
> 原文: <https://www.yuque.com/neumx/ko4psh/nzigpgbrotmvl1d7>