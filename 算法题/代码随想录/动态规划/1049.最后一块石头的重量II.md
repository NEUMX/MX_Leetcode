# 1049. 最后一块石头的重量 II

### 动态规划思路（<font style="color:#DF2A3F;">从石头中选择一些石头，使得它们的总重量尽可能接近所有石头总重量的一半。这就是一个典型的</font>**<font style="color:#DF2A3F;">0-1背包问题</font>**<font style="color:#DF2A3F;">。</font>）
### 思路分析
这个问题可以转化为一个经典的**背包问题**。具体来说，我们可以将问题转化为：将石头分成两堆，使得两堆石头的总重量差最小。这样，最终剩下的石头的重量就是这个差值。

#### 为什么可以转化为背包问题？
假设我们将石头分成两堆，一堆的总重量为 `sum1`，另一堆的总重量为 `sum2`。那么最终剩下的石头的重量就是 `|sum1 - sum2|`。为了使这个差值最小，我们需要让 `sum1` 和 `sum2` 尽可能接近。

这实际上等价于：从石头中选择一些石头，使得它们的总重量尽可能接近所有石头总重量的一半。这就是一个典型的**0-1背包问题**。

### 动态规划解法
我们可以使用动态规划来解决这个问题。具体步骤如下：

1. **计算总重量**：首先计算所有石头的总重量 `totalSum`。
2. **目标重量**：我们希望找到一些石头，使得它们的总重量尽可能接近 `totalSum / 2`。
3. **动态规划数组**：我们使用一个布尔数组 `dp`，其中 `dp[i]` 表示是否存在一些石头，使得它们的总重量等于 `i`。
4. **初始化**：`dp[0] = true`，表示总重量为0是可能的（即不选择任何石头）。
5. **状态转移**：对于每块石头，我们更新 `dp` 数组，表示是否可以通过选择这块石头来达到某个重量。
6. **寻找最大重量**：最后，我们从 `totalSum / 2` 开始向下寻找最大的 `i`，使得 `dp[i]` 为 `true`。这个 `i` 就是我们能够达到的最接近 `totalSum / 2` 的重量。

#### 动态规划代码
```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        // 计算所有石头的总重量
        int sum = 0;
        for (int stone : stones) {
            sum += stone;
        }

        // 目标是将石头分为两堆，使得两堆重量的差值最小
        // 我们尝试接近总重量的一半的最大可能重量
        int target = sum / 2;

        // 动态规划数组 dp
        // dp[j] 表示容量为 j 的背包可以容纳的最大重量
        int[] dp = new int[target + 1];

        // 遍历每块石头
        for (int stone : stones) {
            // 从大到小遍历背包容量，避免重复使用同一块石头
            for (int j = target; j >= stone; j--) {
                // 更新 dp[j]，取当前值和加入当前石头后的值的最大值
                dp[j] = Math.max(dp[j], dp[j - stone] + stone);
            }
        }

        // 最小可能重量 = 总重量 - 2 * dp[target]
        // dp[target] 是接近总重量一半的最大值
        return sum - 2 * dp[target];
    }
}

```

#### 时间复杂度和空间复杂度
+ **时间复杂度**：`O(n * target)`，其中 `n` 是石头的数量，`target` 是总重量的一半。
+ **空间复杂度**：`O(target)`，我们使用了一个大小为 `target + 1` 的布尔数组。





> 更新: 2025-01-16 22:32:58  
> 原文: <https://www.yuque.com/neumx/ko4psh/rlssklc5fnp005xh>