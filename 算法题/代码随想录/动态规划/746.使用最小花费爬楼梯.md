# 746. 使用最小花费爬楼梯

### 解题思路（<font style="color:#DF2A3F;">跟爬楼梯差不多，只不过多加了一个代价</font>）
要解决这个问题，我们可以使用动态规划的方法。具体思路是：

1. **定义状态**：`dp[i]` 表示到达第 `i` 个台阶所需的最低花费。
2. **状态转移方程**：对于第 `i` 个台阶，你可以从第 `i-1` 个台阶爬一步上来，或者从第 `i-2` 个台阶爬两步上来。因此，状态转移方程为：

`dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])`

3. **初始条件**：由于你可以从第 0 个或第 1 个台阶开始爬楼梯，所以 `dp[0] = 0` 和 `dp[1] = 0`。
4. **最终结果**：我们需要到达的是楼梯的顶部，即第 `n` 个台阶（假设 `cost` 数组的长度为 `n`），所以最终结果是 `dp[n]`。

下面是 Java 代码实现：

```java
public class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] dp = new int[n + 1];
        
        // 初始条件
        dp[0] = 0;
        dp[1] = 0;
        
        // 状态转移
        for (int i = 2; i <= n; i++) {
            dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);
        }
        
        // 返回结果
        return dp[n];
    }
}
```

### 代码解释：
+ `dp[0]` 和 `dp[1]` 初始化为 0，因为你可以从第 0 或第 1 个台阶开始爬楼梯，不需要花费。
+ 从第 2 个台阶开始，计算到达每个台阶的最低花费。
+ 最终返回 `dp[n]`，即到达楼梯顶部的最低花费。

### 示例：
假设 `cost = [10, 15, 20]`，那么：

+ `dp[0] = 0`
+ `dp[1] = 0`
+ `dp[2] = min(dp[1] + cost[1], dp[0] + cost[0]) = min(0 + 15, 0 + 10) = 10`
+ `dp[3] = min(dp[2] + cost[2], dp[1] + cost[1]) = min(10 + 20, 0 + 15) = 15`

最终结果是 `dp[3] = 15`，即最低花费为 15。

### 优化：
由于 `dp[i]` 只依赖于 `dp[i-1]` 和 `dp[i-2]`，我们可以用两个变量来替代整个 `dp` 数组，从而将空间复杂度优化为 O(1)。

```java
public class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int prev1 = 0;  // dp[i-1]
        int prev2 = 0;  // dp[i-2]
        
        for (int i = 2; i <= n; i++) {
            int current = Math.min(prev1 + cost[i-1], prev2 + cost[i-2]);
            prev2 = prev1;
            prev1 = current;
        }
        
        return prev1;
    }
}
```

这个优化后的代码在空间上更加高效。好的，我们来分析一下这两个解法的时间复杂度和空间复杂度。

---

### **解法 1：动态规划（使用数组 **`dp`**）**
#### **时间复杂度：O(n)**
+ 因此，时间复杂度为 **O(n)**，其中 `n` 是 `cost` 数组的长度。

#### **空间复杂度：O(n)**
+ 我们使用了一个长度为 `n+1` 的数组 `dp` 来存储每个台阶的最小花费。
+ 因此，空间复杂度为 **O(n)**。

---

### **解法 2：动态规划（优化空间，使用两个变量）**
#### **时间复杂度：O(n)**
+ 和解法 1 一样，我们需要遍历 `cost` 数组一次，计算每个台阶 `i` 的最小花费。
+ 因此，时间复杂度仍然是 **O(n)**。

#### **空间复杂度：O(1)**
+ 我们只使用了两个变量 `prev1` 和 `prev2` 来存储前两个台阶的最小花费。
+ 没有使用额外的数组，因此空间复杂度为 **O(1)**。

---

### 


> 更新: 2025-01-14 21:29:53  
> 原文: <https://www.yuque.com/neumx/ko4psh/nso3ins1h67ys33k>