# 509. 斐波那契数

### 思路（递归和动规，并且动规还有优化）
## 1. 递归解法
### 思路
+ **递归定义**：斐波那契数列的递归定义是：
    - `F(0) = 0`
    - `F(1) = 1`
    - `F(n) = F(n-1) + F(n-2)`（当 `n > 1` 时）
+ **递归终止条件**：当 `n == 0` 或 `n == 1` 时，直接返回 `0` 或 `1`。
+ **问题**：递归解法会重复计算很多子问题，时间复杂度为 `O(2^n)`，效率较低。

### 代码实现
```java
public class Fibonacci {
    // 递归解法
    public int fib(int n) {
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        return fib(n - 1) + fib(n - 2); // 递归调用
    }
}
```

---

## 2. 动态规划解法
### 思路
+ **动态规划**：通过存储中间结果，避免重复计算。
+ **状态定义**：用 `dp[i]` 表示第 `i` 个斐波那契数。
+ **状态转移方程**：`dp[i] = dp[i-1] + dp[i-2]`。
+ **初始化**：`dp[0] = 0`，`dp[1] = 1`。
+ **优化空间**：由于 `dp[i]` 只依赖于前两个状态，可以用两个变量代替数组，将空间复杂度优化到 `O(1)`。

### 代码实现
#### 方法 1：使用数组存储（空间复杂度 O(n)）
```java
public class Fibonacci {
    // 动态规划解法（使用数组）
    public int fib(int n) {
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        int[] dp = new int[n + 1]; // 定义 dp 数组
        dp[0] = 0; // 初始化
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2]; // 状态转移
        }
        return dp[n];
    }
}
```

#### 方法 2：优化空间（空间复杂度 O(1)）
```java
ublic class Fibonacci {
    // 动态规划解法（优化空间）
    public int fib(int n) {
        // 如果 n 为 0，直接返回 0，因为 F(0) = 0
        if (n == 0) {
            return 0;
        }
        // 如果 n 为 1，直接返回 1，因为 F(1) = 1
        if (n == 1) {
            return 1;
        }

        // 初始化变量：
        // prev1 表示 F(n-1)，初始值为 F(1) = 1
        int prev1 = 1;
        // prev2 表示 F(n-2)，初始值为 F(0) = 0
        int prev2 = 0;
        // current 表示当前计算的斐波那契数 F(n)，初始值为 0
        int current = 0;

        // 从 2 开始迭代到 n，计算每个斐波那契数
        for (int i = 2; i <= n; i++) {
            // 计算当前斐波那契数 F(i) = F(i-1) + F(i-2)
            current = prev1 + prev2;
            // 更新 prev2 为 F(i-1)，为下一次迭代做准备
            prev2 = prev1;
            // 更新 prev1 为 F(i)，为下一次迭代做准备
            prev1 = current;
        }

        // 返回最终的斐波那契数 F(n)
        return current;
    }
```

---

## 对比总结
| 方法 | 时间复杂度 | 空间复杂度 | 优点 | 缺点 |
| --- | --- | --- | --- | --- |
| 递归 | O(2^n) | O(n) | 代码简单直观 | 重复计算，效率低 |
| 动态规划 | O(n) | O(n) | 无重复计算，效率高 | 需要额外空间存储数组 |
| 动态规划优化 | O(n) | O(1) | 无重复计算，空间效率高 | 代码稍复杂 |


---

## 笔记要点
1. **递归**：
    - 直接根据定义实现，代码简单。
    - 但存在大量重复计算，效率低。
    - 适合小规模问题或教学演示。
2. **动态规划**：
    - 通过存储中间结果，避免重复计算。
    - 时间复杂度优化到 `O(n)`。
    - 空间复杂度可以进一步优化到 `O(1)`。
3. **优化思路**：
    - 如果只需要最终结果，可以用两个变量代替数组，节省空间。

希望这对你的学习有帮助！如果有其他问题，欢迎随时提问！ 😊



> 更新: 2025-01-13 22:26:42  
> 原文: <https://www.yuque.com/neumx/ko4psh/tsgzlgi1l4ua6neq>