# 222. 完全二叉树的节点个数

### 当然，以下是解决这个问题的思路：
1. **理解完全二叉树的性质**：
    - 完全二叉树除了最后一层外，每一层都是满的。
    - 最后一层的节点都尽可能地靠左排列。
2. **确定递归的结束条件**：
    - 如果当前节点为空（`root == null`），则该子树没有节点，返回0。
3. **计算左右子树的高度**：
    - 对于当前节点，分别计算其左子树和右子树的高度。
    - 计算左子树高度时，从当前节点开始，一直向左走直到遇到空节点，计算走过的步数。
    - 计算右子树高度时，从当前节点开始，一直向右走直到遇到空节点，计算走过的步数。
4. **判断是否为满二叉树**：
    - 如果左子树和右子树的高度相同，那么左子树一定是一棵满二叉树。
    - 满二叉树的节点数可以通过公式 `2^h - 1` 计算，其中 `h` 是树的高度。
5. **递归计算节点数**：
    - 如果左子树和右子树的高度不同，说明左子树不是满二叉树，我们需要分别递归计算左子树和右子树的节点数。
    - 将左子树的节点数、右子树的节点数和当前节点（1）相加，得到整棵树的节点数。
6. **返回结果**：
    - 根据上述判断，返回对应的节点数。  
这个方法的核心在于利用完全二叉树的性质，通过比较左右子树的高度来判断是否为满二叉树，从而减少不必要的递归调用，提高算法的效率。在最好情况下，算法的时间复杂度可以达到 O(logN)，其中 N 是树的节点数。在最坏情况下，时间复杂度为 O(N)，即当树退化成链表时。

---



```java
public class Solution {
    // 定义计算完全二叉树节点个数的函数
    public int countNodes(TreeNode root) {
        // 如果根节点为空，则树中没有节点，返回0
        if (root == null) {
            return 0;
        }
        
        // 初始化左子树和右子树的高度
        int leftHeight = 0;
        int rightHeight = 0;
        
        // 临时节点，用于计算左子树的高度
        TreeNode leftNode = root;
        // 临时节点，用于计算右子树的高度
        TreeNode rightNode = root;

        // 计算左子树的高度，直到最左边的节点
        while (leftNode != null) {
            leftHeight++;
            leftNode = leftNode.left;
        }

        // 计算右子树的高度，直到最右边的节点
        while (rightNode != null) {
            rightHeight++;
            rightNode = rightNode.right;
        }

        // 如果左子树和右子树的高度相同，说明是一棵满二叉树
        if (leftHeight == rightHeight) {
            // 满二叉树的节点数为 2^h - 1，其中 h 是树的高度
            return (1 << leftHeight) - 1;
        }

        // 如果左右子树的高度不同，则递归计算左右子树的节点数，并加上根节点
        return 1 + countNodes(root.left) + countNodes(root.right);
    }
}

```

### 对于这个问题，我们可以分析算法的复杂度：
1. **时间复杂度**：
    - 在最坏的情况下，每次递归我们都需要计算左右子树的高度，这需要 O(logN) 的时间，其中 N 是树中的节点数。在最坏的情况下，树可能是一个链表，我们需要对每个节点进行一次递归调用，因此时间复杂度是 O(N)。
    - 在最好的情况下，如果树是满二叉树，我们可以在 O(logN) 的时间内确定树的节点数，因为每次递归调用我们都可以直接计算出子树的节点数而不需要进一步递归。
2. **空间复杂度**：
    - 空间复杂度主要取决于递归调用的栈深度。在最坏的情况下，递归调用的深度为树的高度，即 O(N)。
    - 在最好的情况下，树的高度为 O(logN)，因此空间复杂度为 O(logN)。  
综上所述，算法的时间复杂度和空间复杂度如下：
+ **时间复杂度**：O(N)（最坏情况），O(logN)（最好情况）
+ **空间复杂度**：O(N)（最坏情况），O(logN)（最好情况）  
这里的 N 是树中节点的总数。在实际应用中，由于完全二叉树的性质，算法的平均时间复杂度通常会接近 O(logN)，因为它不需要遍历所有的节点。



> 更新: 2024-12-18 09:31:18  
> 原文: <https://www.yuque.com/neumx/ko4psh/yg9wfck113nomxbl>