# 77. 组合

### 方法一：**递归回溯**
#### 思路：
回溯算法的核心是通过递归的方式构造解空间树。在每一层递归中，我们尝试做出某个选择，然后进入下一层继续做选择。当达到一个完整的解时，保存当前解，并返回上层继续尝试其他选择。

对于**组合问题**，我们需要从 `1` 到 `n` 中选择 `k` 个数，而每次的选择可以是一个数，并且要求每个数只能选择一次。为了避免重复，我们可以保证在每次选择时，所选的数是递增的，从而避免重复选择。

### 方法二：**剪枝优化回溯**
#### 思路：
剪枝优化回溯的核心思想是在搜索过程中避免无效的递归操作。通过在递归的过程中提前排除掉那些显然不符合条件的路径，能够显著减少计算量，从而提高算法的效率。

对于**组合问题**，剪枝优化的思路是：如果当前已经选择的数字数量加上剩余可选数字的数量已经不足以构成一个合法的 `k` 个数的组合，就可以提前停止搜索，不再继续递归。

---

## 常规做法
```java
import java.util.*;

public class Solution {
    // 结果存储所有组合
    public List<List<Integer>> combine(int n, int k) {
        // 用来存储所有组合的结果
        List<List<Integer>> result = new ArrayList<>();
        // 当前的组合
        List<Integer> current = new ArrayList<>();
        // 从 1 开始进行回溯，尝试选择 k 个数
        backtrack(n, k, 1, current, result);
        return result;
    }

    // 回溯函数：用于构建组合
    private void backtrack(int n, int k, int start, List<Integer> current, List<List<Integer>> result) {
        // 1. 如果当前组合的大小等于 k，保存这个组合
        if (current.size() == k) {
            result.add(new ArrayList<>(current)); // 记录当前的组合
            return; // 结束当前的递归
        }

        // 2. 从 start 到 n 遍历，构建组合
        for (int i = start; i <= n; i++) {
            // 3. 做选择：将当前数字加入组合
            current.add(i);

            // 4. 递归进入下一层，选择下一个数字
            backtrack(n, k, i + 1, current, result);

            // 5. 回溯：撤销当前选择，尝试下一个数字
            current.remove(current.size() - 1);
        }
    }
}

```

##  剪枝优化回溯  
```java
public class Solution {
    // 结果存储所有组合
    public List<List<Integer>> combine(int n, int k) {
        // 用来存储所有组合的结果
        List<List<Integer>> result = new ArrayList<>();
        // 当前的组合
        List<Integer> current = new ArrayList<>();
        // 从 1 开始进行回溯，尝试选择 k 个数
        backtrack(n, k, 1, current, result);
        return result;
    }

    // 回溯函数：用于构建组合
    private void backtrack(int n, int k, int start, List<Integer> current, List<List<Integer>> result) {
        // 1. 如果当前组合的大小等于 k，保存这个组合
        if (current.size() == k) {
            result.add(new ArrayList<>(current)); // 记录当前的组合
            return; // 结束当前的递归
        }

    // 剪枝：如果剩下的元素数目不足以填满当前组合的大小 k，则停止搜索
        for (int i = start; i <= n - (k - current.size()) + 1; i++) {
            // 3. 做选择：将当前数字加入组合
            current.add(i);

            // 4. 递归进入下一层，选择下一个数字
            backtrack(n, k, i + 1, current, result);

            // 5. 回溯：撤销当前选择，尝试下一个数字
            current.remove(current.size() - 1);
        }
    }
```

### 复杂度分析
我们来对比一下这两种方法的**时间复杂度**和**空间复杂度**。

### 1. 递归回溯（无剪枝）
#### 时间复杂度：
+ **递归回溯**的时间复杂度主要取决于生成组合的数量。生成的组合数是 `C(n, k)`，即从 `n` 个元素中选取 `k` 个元素的组合数。
+ 每次递归调用中，我们遍历一次数字，从 `start` 到 `n`。在最坏的情况下，递归的深度是 `k`，每次递归中最多会有 `n` 次的遍历操作。

因此，最坏情况下的时间复杂度是 **O(C(n, k))**，其中 `C(n, k)` 是组合数。

+ **C(n, k)** 的计算公式为： C(n,k)=n!k!(n−k)!C(n, k) = \frac{n!}{k!(n-k)!} 组合数的数量随着 `n` 和 `k` 的不同而变化，通常是一个指数级的数。

#### 空间复杂度：
+ **空间复杂度**由两个部分组成： 
    1. **递归栈的空间**：递归的最大深度是 `k`，因此空间复杂度为 O(k)。
    2. **存储组合的空间**：每个组合的大小是 `k`，且最多有 `C(n, k)` 个组合，所以存储结果的空间复杂度是 O(C(n, k) * k)。

因此，**总的空间复杂度**为 **O(C(n, k) * k)**。

### 2. 剪枝优化回溯
#### 时间复杂度：
+ **剪枝优化回溯**的时间复杂度在最坏情况下与递归回溯相同，都是 **O(C(n, k))**。剪枝优化并不会改变组合数的总量（最坏情况下依然会生成 `C(n, k)` 个组合）。
+ 剪枝的作用是减少不必要的递归调用，但在最坏情况下，剪枝并不能完全消除所有的递归分支，因此最坏时间复杂度仍然是 **O(C(n, k))**。

然而，剪枝在实际应用中通常能显著提升效率，减少计算量。尤其是在大部分路径都能被剪掉的情况下，时间开销会减少，实际的运行时间要小于没有剪枝的情况。

#### 空间复杂度：
+ **空间复杂度**与递归回溯相同，包括递归栈的空间和存储结果的空间： 
    - 递归栈的空间复杂度是 O(k)。
    - 存储所有组合的空间复杂度是 O(C(n, k) * k)。

因此，**总的空间复杂度**是 **O(C(n, k) * k)**，与递归回溯的方法相同。

---

### 总结：
| **方法** | **时间复杂度** | **空间复杂度** |
| --- | --- | --- |
| **递归回溯（无剪枝）** | O(C(n, k)) | O(C(n, k) * k) |
| **剪枝优化回溯** | O(C(n, k)) | O(C(n, k) * k) |


+ **时间复杂度**：两者在最坏情况下的时间复杂度相同，都是 **O(C(n, k))**，因为最终生成的组合数是相同的。剪枝的优化并没有改变最坏情况的组合数，但它能显著减少一些不必要的递归调用，从而提高实际运行效率。
+ **空间复杂度**：两者的空间复杂度相同，因为递归栈的深度最大为 `k`，同时需要存储所有的组合。存储所有组合的空间复杂度是 **O(C(n, k) * k)**，与是否剪枝无关。

总的来说，**剪枝优化**虽然最坏情况的时间复杂度和空间复杂度不变，但它通常能显著减少实际运行时间，特别是在许多递归分支被剪除的情况下。











> 更新: 2024-12-28 21:28:07  
> 原文: <https://www.yuque.com/neumx/ko4psh/bhibg33ys5e0dozu>