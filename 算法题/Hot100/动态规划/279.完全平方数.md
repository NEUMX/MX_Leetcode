# 279. 完全平方数

### 解题思路（<font style="color:#DF2A3F;">完全背包问题，这里是找到最小的i平方，加起来等于n，</font>`<font style="color:#DF2A3F;">dp[i] = min(dp[i], dp[i - j*j] + 1)</font>`）
### 问题分析
+ **目标**：找到最少的完全平方数，使它们的和等于给定的整数 `n`。
+ **完全平方数**：如 1（1²）、4（2²）、9（3²）、16（4²）等。
+ **思路**：可以用动态规划来解决，类似于“零钱兑换”问题。
    - 对于每个数字 `n`，我们尝试用所有可能的完全平方数去减它，然后求剩余部分的最优解。
    - 最终取所有可能情况中的最小值。

### 动态规划解法
+ **定义状态**：`dp[i]` 表示数字 `i` 能由最少多少个完全平方数表示。
+ **状态转移方程**：
    - 对于每个 `i`，枚举所有小于等于 `i` 的完全平方数 `j*j`：
    - `dp[i] = min(dp[i], dp[i - j*j] + 1)`，其中 `j*j` 是一个完全平方数。
+ **初始条件**：
    - `dp[0] = 0`（和为 0 不需要任何完全平方数）。
+ **边界**：
    - 对于每个 `i`，初始时可以设为 `i`（最坏情况下用 `i` 个 1 表示）。

### Java 代码
```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        
        // 初始化 dp 数组
        for (int i = 0; i <= n; i++) {
            dp[i] = i; // 最坏情况下，用 i 个 1
        }
        
        // 动态规划
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j * j <= i; j++) {
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
            }
        }
        
        return dp[n];
    }
}
```

### 代码解释
1. **初始化**：
    - 创建一个大小为 `n+1` 的数组 `dp`，`dp[i]` 表示和为 `i` 的最少完全平方数个数。
    - 最坏情况下，`dp[i] = i`（用 `i` 个 1 表示）。
2. **动态规划过程**：
    - 外层循环遍历从 1 到 n 的每个数字 `i`。
    - 内层循环枚举所有可能的完全平方数 `j*j`，只要 `j*j <= i`。
    - 对于每个 `i`，尝试用 `j*j` 表示一部分，然后剩余部分 `i - j*j` 的最优解加上 1（用了 `j*j` 这个数）。
    - 更新 `dp[i]` 为所有可能情况中的最小值。
3. **返回结果**：
    - `dp[n]` 就是最终答案。

### 时间和空间复杂度
+ **时间复杂度**：O(n * √n)，外层循环 O(n)，内层循环枚举完全平方数，个数为 O(√n)。
+ **空间复杂度**：O(n)，使用了大小为 n+1 的 dp 数组。



### 


> 更新: 2025-02-28 21:22:57  
> 原文: <https://www.yuque.com/neumx/ko4psh/hh26g4vugnxzhxfo>