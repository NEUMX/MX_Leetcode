# 279. 完全平方数

### 解题思路（<font style="color:#DF2A3F;">完全背包问题，这里是找到最小的i平方，加起来等于n，</font>`<font style="color:#DF2A3F;">dp[i] = min(dp[i], dp[i - j*j] + 1)</font>`）
### 问题分析
+ **目标**：找到最少的完全平方数，使它们的和等于给定的整数 `n`。
+ **完全平方数**：如 1（1²）、4（2²）、9（3²）、16（4²）等。
+ **思路**：可以用动态规划来解决，类似于“零钱兑换”问题。
    - 对于每个数字 `n`，我们尝试用所有可能的完全平方数去减它，然后求剩余部分的最优解。
    - 最终取所有可能情况中的最小值。

你提供的代码中，确实有一些错误，我来帮你分析一下。

### **问题分析：**

1. **`i` 的循环范围错误：** 在你编写的代码中，`i` 的循环范围是 `i = 0` 到 `i < n`，但我们需要遍历的是所有小于等于 `n` 的完全平方数，也就是 `i` 的最大值应该是 `sqrt(n)`。

   * **问题：** `i` 的循环应该是遍历完全平方数的根，也就是 `i * i` 的数值，而不是 `i` 本身。

2. **更新 `dp[j]` 的公式错误：** 在 `dp[j]` 的更新中，你的公式是 `dp[j] = Math.max(dp[j], dp[n - j] + 1)`。但实际上你应该是通过 `dp[j - i * i] + 1` 来更新 `dp[j]`，而不是用 `dp[n - j]`。

### **修改后的代码：**

```java
class Solution {
    public int numSquares(int n) {
        // dp[i] 表示组成 i 的最小完全平方数个数
        int[] dp = new int[n + 1];
        
        // 初始化 dp 数组，dp[0] = 0，表示 0 需要 0 个完全平方数
        for (int i = 1; i <= n; i++) {
            dp[i] = Integer.MAX_VALUE; // 设置一个大值表示尚未计算过
        }

        // 遍历所有可能的完全平方数
        for (int i = 1; i * i <= n; i++) {
            for (int j = i * i; j <= n; j++) {
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);  // 状态转移方程
            }
        }

        // 返回 dp[n]，即组成 n 的最小完全平方数的个数
        return dp[n];
    }
}
```

### **修改点：**

1. **遍历完全平方数**：外层循环应该遍历 `i` 从 `1` 到 `sqrt(n)`，`i * i` 是完全平方数。
2. **`dp[j]` 的更新公式**：更新 `dp[j]` 时应该是 `dp[j - i * i] + 1`，表示我们用一个完全平方数 `i * i` 来构成 `j`，然后查看剩余部分 `j - i * i` 的最小完全平方数。

### **代码解释：**

* `dp[i]` 表示组成 `i` 的最小完全平方数的个数。
* 初始时，我们将 `dp[0]` 设为 `0`，因为 `0` 不需要任何完全平方数。
* 遍历所有小于等于 `n` 的完全平方数（`i * i`），并更新 `dp[j]`，让每个 `j` 最终得到最小的完全平方数个数。

### **时间复杂度：**

* 外层循环遍历所有小于等于 `sqrt(n)` 的整数，内层循环遍历 `n`。因此时间复杂度是 `O(n * sqrt(n))`。

### **空间复杂度：**

* 使用了一个大小为 `n + 1` 的 `dp` 数组，所以空间复杂度是 `O(n)`。

---

这样修改之后，代码就能正确运行了。如果有任何其他问题，欢迎继续提问！
