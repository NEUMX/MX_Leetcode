# 169. 多数元素

### 解题思路（<font style="color:#DF2A3F;">候选人，相等的话就加 1，不等就减 1，count=0 的话，就重新候选</font>）
### 解题思路
我们可以使用 **Boyer-Moore 投票算法** 来解决这个问题，这是一种非常高效的方法，能够在 **O(n)** 时间复杂度和 **O(1)** 空间复杂度内找到多数元素。

#### Boyer-Moore 投票算法的核心思路：
1. **候选人选举**：我们首先设定一个候选人 `candidate`，并用一个计数器 `count` 来记录该候选人的支持度。
    - 遍历数组，对于每个元素：
        * 如果 `count` 为 0，说明当前候选人已经没有足够的支持，更新候选人为当前元素，并将 `count` 设为 1。
        * 如果当前元素等于候选人，则增加 `count`。
        * 如果当前元素不等于候选人，则减少 `count`。
2. **第二轮验证**：由于题目中已保证数组总是存在多数元素，因此我们不需要再做第二轮验证，直接返回最终的候选人即可。

### 为什么 Boyer-Moore 算法能有效：
+ 对于多数元素，尽管它的出现次数可能会被其他元素抵消，但最终它的计数会超过数组大小的一半，因此在遍历结束后，候选人 `candidate` 必定是多数元素。

### Java 代码实现
```java
public class Solution {
    public int majorityElement(int[] nums) {
        int candidate = nums[0];  // 初始候选人
        int count = 1;  // 候选人计数
        
        // 第一遍遍历，选出候选人
        for (int i = 1; i < nums.length; i++) {
            if (count == 0) {
                candidate = nums[i];
                count = 1;
            } else if (nums[i] == candidate) {
                count++;
            } else {
                count--;
            }
        }
        
        return candidate;  // 返回最终的候选人
    }
}

```

### 详细解答过程
1. **初始化**：首先将第一个元素 `nums[0]` 设为候选人，并将 `count` 设置为 1。
2. **遍历数组**：从第二个元素开始，遍历整个数组：
    - 如果 `count == 0`，说明当前候选人不再有足够的支持，我们就将当前元素设置为新的候选人，并将 `count` 设为 1。
    - 如果当前元素等于候选人，说明我们得到了更多支持，`count++`。
    - 如果当前元素与候选人不同，说明候选人失去了一部分支持，`count--`。
3. **最终结果**：经过遍历后，`candidate` 就是我们所需要的多数元素。

### 时间复杂度
+ **时间复杂度**：O(n)，我们只需要遍历一次数组。
+ **空间复杂度**：O(1)，我们只用了常数空间来存储候选人和计数器。



> 更新: 2025-02-27 21:23:42  
> 原文: <https://www.yuque.com/neumx/ko4psh/osxuugpwdncb6k5v>