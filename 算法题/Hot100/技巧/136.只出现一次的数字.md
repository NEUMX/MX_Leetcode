# 136. 只出现一次的数字

### 解题思路（<font style="color:#DF2A3F;">异或实现</font>）
基于这些性质，如果我们将数组中的所有元素进行异或运算，成对出现的元素会相互抵消掉（因为 `x ⊕ x = 0`），最终剩下的就是那个只出现一次的元素。

### 解法
1. 初始化一个变量 `result = 0`。
2. 遍历数组中的每个元素 `num`，不断将 `result` 与 `num` 进行异或操作：`result ^= num`。
3. 最后，`result` 中存储的就是那个只出现一次的元素。

### Java 代码实现
```java
public class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;
        for (int num : nums) {
            result ^= num;  // 异或操作
        }
        return result;
    }
}

```

### 代码解释
1. `**result**`** 初始化为 0**：  
由于任何数与 0 异或都会得到自己，所以初始化 `result = 0` 是合理的。
2. **遍历数组并进行异或操作**：  
对数组中的每个元素 `num` 进行异或操作。由于相同的元素会抵消（`x ⊕ x = 0`），最终 `result` 就会存储那个只出现一次的元素。
3. **返回 **`**result**`：  
最后，`result` 就是那个只出现一次的元素。

### 时间和空间复杂度
+ **时间复杂度**：  
遍历数组一次，时间复杂度为 `O(n)`，其中 `n` 是数组的长度。
+ **空间复杂度**：  
只使用了常量级别的额外空间（一个 `int` 变量），所以空间复杂度是 `O(1)`。

##  变成有序数组，需要O(logN)复杂度  
如果数组已经是有序的，并且你希望在 O(logN) 的时间复杂度下找到只出现一次的元素，那么你可以利用二分查找的方法来解决问题。具体来说，在有序数组中，重复的元素总是成对出现。由于数组是有序的，可以通过二分查找来缩小查找范围。

### 解题思路
1. **有序数组的性质**：在一个有序数组中，成对出现的元素一定会成对地出现在数组的相邻位置。所以，如果某个元素的左边或右边没有成对的元素，则说明它就是唯一的那个元素。
2. **二分查找的关键点**：通过判断中间元素的左右相邻元素，来决定搜索的区间。 
    - 如果中间元素 `nums[mid]` 的左右相邻元素是成对的，那么唯一的元素一定在右半部分或者左半部分。
    - 如果中间元素 `nums[mid]` 不成对，那么我们可以确定它就是唯一的那个元素。

### 具体步骤
1. 使用二分查找的方法，设置 `left` 为 0，`right` 为数组的最后一个索引。
2. 计算中间索引 `mid = (left + right) / 2`。
3. 判断 `mid` 位置的元素是否与其相邻元素匹配： 
    - 如果 `nums[mid] == nums[mid-1]` 或 `nums[mid] == nums[mid+1]`，根据匹配的情况确定搜索的区间。
    - 如果不匹配，则说明当前的 `mid` 就是唯一的元素。
4. 在每一步的二分查找中，我们会减小搜索区间，最终找到那个只出现一次的元素。

### Java代码实现
```java
public class Solution {
    public int singleNonDuplicate(int[] nums) {
        int left = 0, right = nums.length - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;  // 防止溢出
            // 确保 mid 是偶数
            if (mid % 2 == 1) {
                mid--;  // 如果 mid 是奇数，向左移一位，保证 mid 总是偶数
            }
            // 如果 nums[mid] 与 nums[mid+1] 相等，说明唯一的元素在右边
            if (nums[mid] == nums[mid + 1]) {
                left = mid + 2;
            } else {
                right = mid;
            }
        }
        
        // left == right 时，就是唯一的元素
        return nums[left];
    }
}
```

### 详细解答过程
1. **初始化 **`**left**`** 和 **`**right**`：设置左右边界，`left = 0`，`right = nums.length - 1`。
2. **二分查找**： 
    - 每次计算 `mid`，我们保证 `mid` 是偶数（这很重要，因为偶数位置的元素应该与后面的元素匹配）。如果 `mid` 是奇数，则将其减 1，使其变为偶数。
    - 比较 `nums[mid]` 和 `nums[mid+1]`： 
        * 如果 `nums[mid] == nums[mid + 1]`，则说明唯一的元素在 `mid` 之后（因为成对的元素已经匹配，唯一的元素应该在右侧），因此我们将 `left = mid + 2`。
        * 如果 `nums[mid] != nums[mid + 1]`，说明唯一的元素要么是 `mid`，要么在左边，设置 `right = mid`。
3. **终止条件**：当 `left` 等于 `right` 时，数组中唯一的元素就是 `nums[left]`。

### 时间复杂度
+ 时间复杂度是 O(logN)，因为每次我们都将查找区间缩小了一半。

### 空间复杂度
+ 空间复杂度是 O(1)，只用了常数空间。



> 更新: 2025-02-27 21:12:49  
> 原文: <https://www.yuque.com/neumx/ko4psh/vkku92pikb62gmqg>