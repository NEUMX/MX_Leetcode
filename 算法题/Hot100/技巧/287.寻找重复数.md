# 287. 寻找重复数

### 解题思路（**<font style="color:#DF2A3F;">数组视为链表，每个元素的值指向下一个元素的位置，如果存在重复数，链表会有环，所以使用快慢指针的思路来检测环，比如数组</font>**`**<font style="color:#DF2A3F;">[1, 3, 4, 2, 2]</font>**`**<font style="color:#DF2A3F;"> 变成链表的样子：   1 → 3 → 2 → 4 → 2 → 4 → 2 →  </font>**）
### 思路：
由于数组中的元素值在 `[1, n]` 范围内，且数组的长度是 `n + 1`，这就意味着至少存在一个重复的数字。我们可以将数组视为一个链表，其中每个元素的值指示了下一个元素的位置，因此可以利用**快慢指针**的思想来检测环。

### 步骤：
1. **构造链表**：
    - 数组中的每个值 `nums[i]` 都是指向下一个索引的位置，因此可以将每个元素视为链表中的一个节点。重复的数字会导致链表形成环。
2. **快慢指针**：
    - **慢指针**每次移动一步，**快指针**每次移动两步。由于链表中存在环，慢指针和快指针最终会相遇。
    - 当慢指针和快指针相遇时，说明存在环。接下来，我们需要找到环的起始点，也就是重复的数字。
3. **寻找环的起始位置**：
    - 一旦快慢指针相遇，我们可以将其中一个指针移动到链表的起点，保持另一个指针不动。然后，两个指针每次都移动一步，它们最终会在环的起始位置相遇，即重复的数字。

### Java 代码实现
```java
public class Solution {
    public int findDuplicate(int[] nums) {
        // 步骤 1: 快慢指针初始化
        int slow = nums[0];
        int fast = nums[0];
        
        // 步骤 2: 找到相遇点
        do {
            slow = nums[slow];          // 慢指针每次走一步
            fast = nums[nums[fast]];    // 快指针每次走两步
        } while (slow != fast); // 当快慢指针相遇时，跳出
        
        // 步骤 3: 寻找环的入口
        slow = nums[0];  // 将慢指针移到数组的起点
        while (slow != fast) {
            slow = nums[slow];  // 慢指针每次走一步
            fast = nums[fast];  // 快指针每次走一步
        }
        
        // 返回重复的数字
        return slow;
    }
}

```

### 解答过程：
1. **初始化快慢指针**：
    - 将慢指针和快指针都初始化为数组的第一个元素，即 `slow = nums[0]` 和 `fast = nums[0]`。
2. **快慢指针相遇**：
    - 慢指针每次走一步，快指针每次走两步。由于数组中存在重复元素，快指针和慢指针最终会相遇。
3. **找到环的入口**：
    - 当快慢指针相遇时，我们将慢指针重置为数组的起点，然后慢指针和快指针每次都走一步，最终它们会在重复数字的位置相遇。
4. **返回重复的数字**：
    - 当快慢指针相遇时，指针所在的位置即为重复的数字。

### 时间复杂度：
+ 快慢指针的相遇过程需要遍历数组的长度，因此时间复杂度为 O(n)。
+ 由于只使用了常量的额外空间，空间复杂度为 O(1)。



> 更新: 2025-02-27 22:06:10  
> 原文: <https://www.yuque.com/neumx/ko4psh/sgr4p7528aw2qmh8>