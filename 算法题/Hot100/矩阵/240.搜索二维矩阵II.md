# 240. 搜索二维矩阵 II

### 解题思路（<font style="color:#DF2A3F;">从右上角开始找</font>）
1. 考虑到每一行和每一列都已经排序了，我们可以利用**从右上角**或**左下角**的搜索策略进行高效查找。

#### 从右上角开始搜索：
1. **初始位置**：从矩阵的右上角（即 `matrix[0][n-1]`）开始。
2. **比较目标值**：
    - 如果当前元素等于目标值 `target`，则返回 `true`，说明找到了目标值。
    - 如果当前元素大于目标值 `target`，则说明目标值可能在当前元素的左边（因为当前行已经升序排列），因此向左移动一步。
    - 如果当前元素小于目标值 `target`，则说明目标值可能在当前元素的下方（因为当前列已经升序排列），因此向下移动一步。
3. **继续移动**：根据上述比较结果继续向左或向下移动，直到找到目标值或超出矩阵的边界。

#### 为什么从右上角开始？
+ 如果当前元素大于目标值，我们可以排除当前列的所有元素，因为当前列已经升序排列，所有小于当前元素的值都在当前元素的上方。
+ 如果当前元素小于目标值，我们可以排除当前行的所有元素，因为当前行已经升序排列，所有大于当前元素的值都在当前元素的右边。

这种方法的时间复杂度为 **O(m + n)**，其中 `m` 是矩阵的行数，`n` 是矩阵的列数。

---

```java
public class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }

        int m = matrix.length;
        int n = matrix[0].length;

        // 从右上角开始搜索
        int row = 0;
        int col = n - 1;

        while (row < m && col >= 0) {
            if (matrix[row][col] == target) {
                return true; // 找到目标值
            } else if (matrix[row][col] > target) {
                col--; // 当前元素大于目标值，向左移动
            } else {
                row++; // 当前元素小于目标值，向下移动
            }
        }

        return false; // 没有找到目标值
    }
}

```

### 代码解析：
1. **输入校验**：首先检查输入矩阵是否为空，或者是否存在空行或空列。
2. **初始化搜索位置**：将搜索的起始位置设为右上角，`row = 0` 和 `col = n - 1`。
3. **搜索循环**：
    - 如果当前元素等于目标值，返回 `true`。
    - 如果当前元素大于目标值，则向左移动一列。
    - 如果当前元素小于目标值，则向下移动一行。
4. **结束条件**：当 `row` 超出矩阵的行数或 `col` 小于 0 时，表示没有找到目标值，返回 `false`。

### 时间复杂度：
+ **时间复杂度**：O(m + n)，我们在最坏情况下可能会移动 `m` 行和 `n` 列，因此时间复杂度是 O(m + n)。
+ **空间复杂度**：O(1)，这是一个原地算法，不需要额外的空间。







> 更新: 2025-02-19 20:51:31  
> 原文: <https://www.yuque.com/neumx/ko4psh/aqz0wf4ts5fse8dn>