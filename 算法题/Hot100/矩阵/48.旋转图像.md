# 48. 旋转图像

### 解题思路（<font style="color:#DF2A3F;">先按照对角线进行翻转，然后再水平翻转每一行</font>）
1. **沿主对角线进行转置**：将矩阵的元素沿主对角线（即从左上到右下的对角线）交换位置，完成转置操作。
2. **水平翻转每一行**：在转置后，按行反转矩阵，使得矩阵顺时针旋转 90 度。

### 详细解析：
#### 1. **主对角线翻转（转置矩阵）**：
+ **转置的定义**：矩阵转置是将矩阵中的元素 matrix[i][j]matrix[i][j]matrix[i][j] 交换为 matrix[j][i]matrix[j][i]matrix[j][i]，即行和列的位置互换。
+ 对于一个 n×nn \times nn×n 的矩阵，转置是通过交换上三角部分的元素来完成的，因此我们只需要遍历矩阵的上三角部分（包括对角线）。

具体的实现：

+ 遍历矩阵的上三角部分（`i` 从 0 到 `n-1`，`j` 从 `i` 到 `n-1`）。
+ 对每对 `matrix[i][j]` 和 `matrix[j][i]` 进行交换，完成转置操作。

#### 2. **反转每一行**：
+ 转置操作完成后，我们需要对每一行进行水平翻转，使得矩阵顺时针旋转 90 度。
+ 水平翻转的方式是交换矩阵中的第 `i` 行的第 `j` 个元素和第 `n - 1 - j` 个元素，直到遍历到行的中间。

具体实现：

+ 对于每一行，交换 `matrix[i][j]` 和 `matrix[i][n - 1 - j]`，直到 `j` 达到行的一半。

---

```java
public class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length; // 获取矩阵的行数，同时也是列数，因为矩阵是n x n的

        // 沿主对角线翻转矩阵
        for (int i = 0; i < n; i++) { // 遍历矩阵的上三角部分（包括对角线）
            for (int j = i; j < n; j++) { // 从对角线开始到矩阵的右边界
                // 交换matrix[i][j]和matrix[j][i]的值
                int temp = matrix[i][j]; // 使用临时变量保存matrix[i][j]的值
                matrix[i][j] = matrix[j][i]; // 将matrix[j][i]的值赋给matrix[i][j]
                matrix[j][i] = temp; // 将临时保存的值赋给matrix[j][i]
            }
        }

        // 反转每一行
        for (int i = 0; i < n; i++) { // 遍历矩阵的每一行
            for (int j = 0; j < n / 2; j++) { // 只需遍历到每行的一半即可
                // 交换matrix[i][j]和matrix[i][n - 1 - j]的值
                int temp = matrix[i][j]; // 使用临时变量保存matrix[i][j]的值
                matrix[i][j] = matrix[i][n - 1 - j]; // 将matrix[i][n - 1 - j]的值赋给matrix[i][j]
                matrix[i][n - 1 - j] = temp; // 将临时保存的值赋给matrix[i][n - 1 - j]
            }
        }
    }
}

```

### 代码解析：
1. **主对角线翻转**：
    - 外层循环遍历矩阵的每一行（`i` 从 0 到 `n-1`）。
    - 内层循环从对角线开始遍历矩阵的上三角部分（`j` 从 `i` 到 `n-1`）。对于每个元素 `matrix[i][j]` 和 `matrix[j][i]`，交换它们的值，完成转置。
2. **反转每一行**：
    - 对矩阵中的每一行（`i` 从 0 到 `n-1`），内层循环遍历该行的前一半（`j` 从 0 到 `n/2 - 1`），交换当前行的第 `j` 个元素和第 `n-1-j` 个元素，完成水平翻转。

### 时间复杂度和空间复杂度：
+ **时间复杂度**：O(n^2)，矩阵的大小是 n×n，转置操作和水平翻转操作各自的时间复杂度为 O(n^2)，因此总的时间复杂度为 O(n^2)。
+ **空间复杂度**：O(1)，该方法通过原地交换矩阵的元素，因此没有使用额外的空间，空间复杂度为 O(1)。







> 更新: 2025-02-19 20:44:34  
> 原文: <https://www.yuque.com/neumx/ko4psh/bgydnh34sz8vqwby>