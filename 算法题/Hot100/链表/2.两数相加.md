# 2. 两数相加

### 思路（<font style="color:#DF2A3F;">逐位相加两个链表的节点值，处理进位，构造新的结果链表。</font>）
题目要求我们将两个链表表示的数字相加，并返回一个表示和的链表。两个链表中每个节点存储一个数字，且数字是以 **逆序** 形式存储的，即链表的头节点表示最低位。

### 解决思路
1. **逐位相加**：从两个链表的头节点开始，每次对两个链表对应位的数字进行相加。由于可能会有进位，所以需要记录进位。
2. **进位处理**：如果两数之和大于或等于 10，则将进位（carry）设置为 1，并将当前节点的值设置为和的个位数；如果小于 10，则进位为 0。
3. **处理不同长度的链表**：如果两个链表的长度不同，我们可以在较短的链表后面补上 0，直到两个链表的长度相同。
4. **结束条件**：遍历两个链表直到两个链表都遍历完。如果最后有进位需要处理，则再加一个节点。

#### 代码
```java
public class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // 创建虚拟头节点，方便操作
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        int carry = 0;  // 进位

        // 逐位相加
        while (l1 != null || l2 != null || carry != 0) {
            int x = (l1 != null) ? l1.val : 0;  // 如果l1不为空，则取l1的值，否则为0
            int y = (l2 != null) ? l2.val : 0;  // 如果l2不为空，则取l2的值，否则为0
            int sum = x + y + carry;  // 计算当前位的和

            carry = sum / 10;  // 计算进位
            current.next = new ListNode(sum % 10);  // 当前位的数字
            current = current.next;  // 移动到下一个节点

            // 移动l1和l2指针
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }

        return dummy.next;  // 返回合并后的链表
    }
}

```

### 解释：
1. **虚拟头节点**：为了简化边界条件的处理，创建一个虚拟头节点 `dummy`，最后返回 `dummy.next` 作为结果链表的头节点。
2. **进位处理**：通过 `carry` 变量来记录进位的值。如果两个数字的和大于或等于 10，则将 `carry` 设为 1，否则设为 0。
3. **遍历链表**：使用 `while (l1 != null || l2 != null || carry != 0)` 来遍历两个链表，直到两个链表都为空并且没有进位为止。这样可以处理两个链表长度不一样的情况。
4. **逐位相加**：
    - `x` 和 `y` 分别表示当前位的两个数字，如果对应的链表已经结束，则用 0 填充。
    - `sum` 是当前位的和，包括进位部分。新的节点值是 `sum % 10`，即个位数。
    - `carry` 是当前位的进位，是 `sum / 10`。

### 时间复杂度：
+ **时间复杂度**：O(max(n, m))，其中 `n` 和 `m` 分别是两个链表的长度。我们最多遍历两个链表一次，处理每个节点。

### 空间复杂度：
+ **空间复杂度**：O(max(n, m))，我们需要一个新的链表来存储结果，最坏情况下新链表的长度为两个链表长度的最大值。



> 更新: 2025-03-24 16:56:45  
> 原文: <https://www.yuque.com/neumx/ko4psh/ize5b5vg44sgthtx>