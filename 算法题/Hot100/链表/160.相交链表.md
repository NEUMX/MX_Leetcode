# 160. 相交链表

### 思路（两个指针 a 和 b， <font style="color:#DF2A3F;">让a和b都走一样的路径，找到相交节点（哪怕没有节点，最后都为null了）</font>）
我们可以通过使用**双指针**的技巧来解决这个问题。具体步骤如下：

1. **双指针法**：
    - 我们可以分别从链表 A 和链表 B 的头部出发，用两个指针 `pA` 和 `pB` 分别遍历链表 A 和链表 B。
    - 当一个指针到达链表的末尾时，它将被指向另一个链表的头节点。这样，两个指针将以相同的速度遍历两个链表的节点，并最终有可能在相交的节点上相遇。
2. **为什么能相遇**：
    - 假设链表 A 的长度是 `m`，链表 B 的长度是 `n`。如果链表 A 和链表 B 相交，则它们的相交部分的长度是相同的。通过指针切换到另一个链表后，两个指针分别经历了两个链表的长度差异，最终可以在相交节点处相遇。
    - 具体来说，两个指针在遍历各自链表的过程中，第二次遍历的路径长度相等。
3. **无相交情况**：
    - 如果两个链表没有交点，那么两个指针最终会同时遍历到 `null`，退出循环。

#### 代码
```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // 初始化两个指针
        ListNode pA = headA;
        ListNode pB = headB;

        // 遍历直到两个指针相遇或都为 null
        while (pA != pB) {
            // 遍历链表 A
            pA = (pA == null) ? headB : pA.next;
            // 遍历链表 B
            pB = (pB == null) ? headA : pB.next;
        }

        // 如果相交，pA（或 pB）指向相交节点；如果没有相交，返回 null
        return pA;
    }
}
```

### 时间和空间复杂度
+ **时间复杂度**：O(m + n)，其中 m 和 n 分别是两个链表的长度。每个指针最多遍历两个链表的长度。
+ **空间复杂度**：O(1)，我们只使用了两个指针，没有额外的空间开销。





> 更新: 2025-03-24 16:22:48  
> 原文: <https://www.yuque.com/neumx/ko4psh/xihwfrx92kytrfts>