# 76. 最小覆盖子串

### 思路（<font style="color:#DF2A3F;"> 采用字符数组记录字符频率，通过滑动窗口找到 s 中包含 t 所有字符的最小子串。</font>  ）
### 解题思路
这个解法采用了 **滑动窗口** 的策略，结合 **字符计数** 来找出 `s` 中包含 `t` 所有字符的最小子串。具体思路如下：

1. **字符计数**：
    - 使用两个数组 `need` 和 `window` 来记录字符出现次数。
        * `need` 数组记录了 `t` 中每个字符的出现次数。
        * `window` 数组记录了当前滑动窗口中每个字符的出现次数。
2. **滑动窗口**：
    - 利用两个指针 `left` 和 `right` 来表示当前窗口的左右边界，右指针扩展窗口，左指针收缩窗口。
    - 右指针从左到右遍历字符串 `s`，扩展窗口。
    - 当窗口包含了 `t` 中所有字符时，尝试通过左指针来收缩窗口，以找到最小的覆盖子串。
3. **窗口有效性**：
    - 维护一个 `valid` 变量，表示当前窗口中已满足 `t` 中字符要求的字符数。
    - 如果窗口中的字符数量满足 `t` 中的要求（即 `valid == t.length()`），则表示窗口包含了 `t` 中所有字符。
4. **更新最小子串**：
    - 每当窗口包含了所有字符时，检查当前窗口的长度，如果小于之前记录的最小长度，则更新最小子串的起始位置和长度。
5. **缩小窗口**：
    - 为了尝试找到更小的覆盖子串，每次左指针向右移动时，更新窗口内的字符计数，必要时减少有效字符的计数。
6. **返回结果**：
    - 如果找到了最小子串，则返回；如果没有找到符合条件的子串，则返回空字符串。

#### 代码
```java
public class Solution {
    public String minWindow(String s, String t) {
        // ASCII码表长度
        int[] need = new int[128]; // 用于记录字符串t中每个字符需要的次数
        int[] window = new int[128]; // 用于记录当前窗口中每个字符出现的次数

        // 初始化需要的字符及其数量
        for (char c : t.toCharArray()) {
            need[c]++; // 将t中的字符的出现次数记录到need数组中
        }

        int left = 0, right = 0, valid = 0; // 初始化左右指针和有效字符计数器
        int start = 0, length = Integer.MAX_VALUE; // 初始化最小覆盖子串的起始索引和长度

        // 滑动窗口过程
        while (right < s.length()) {
            char c = s.charAt(right); // 获取当前右指针指向的字符
            right++; // 右指针向右移动

            // 如果当前字符是需要的字符，更新窗口内数据
            if (need[c] > 0) {
                window[c]++; // 当前字符在窗口中的计数增加
                // 如果当前字符在窗口中的计数小于等于在t中的计数，则有效字符计数增加
                if (window[c] <= need[c]) {
                    valid++;
                }
            }

            // 当窗口中的有效字符数量等于t的长度时，表示窗口包含了t中所有字符
            while (valid == t.length()) {
                // 如果当前窗口的长度小于已记录的最小长度，则更新最小长度和起始位置
                if (right - left < length) {
                    start = left; // 更新最小覆盖子串的起始位置
                    length = right - left; // 更新最小覆盖子串的长度
                }
                char d = s.charAt(left); // 获取当前左指针指向的字符
                left++; // 左指针向右移动

                // 如果当前字符是需要的字符，更新窗口内数据
                if (need[d] > 0) {
                    // 如果当前字符在窗口中的计数等于在t中的计数，则有效字符计数减少
                    if (window[d] == need[d]) {
                        valid--;
                    }
                    window[d]--; // 当前字符在窗口中的计数减少
                }
            }
        }

        // 如果最小长度没有变化，说明没有符合条件的子串，返回空字符串
        // 否则，返回最小覆盖子串
        return length == Integer.MAX_VALUE ? "" : s.substring(start, start + length);
    }
}

```

### 代码详解：
1. **初始化 **`**need**`** 数组**：
    - `need` 数组大小为 128，表示 ASCII 字符集的大小。通过遍历字符串 `t`，记录其中每个字符的出现次数。
2. **滑动窗口**：
    - `left` 和 `right` 初始化为 0，分别表示滑动窗口的左右边界。
    - `valid` 用来记录当前窗口中符合条件的字符个数，要求该字符的数量不能少于 `t` 中该字符的数量。
3. **扩展窗口**：
    - 通过移动右指针 `right`，每次将右边的字符加入窗口中，并更新窗口中的字符计数。
4. **收缩窗口**：
    - 一旦窗口包含了 `t` 中所有字符（即 `valid == t.length()`），就尝试通过移动左指针 `left` 来缩小窗口。
    - 每次移动左指针时，更新窗口中的字符计数，并根据需要更新 `valid` 值。
5. **更新最小覆盖子串**：
    - 当窗口包含所有字符时，比较当前窗口的大小是否小于已记录的最小子串。如果小于，则更新最小子串的起始位置和长度。
6. **返回结果**：
    - 如果找到了有效的最小子串，则返回它；否则返回空字符串 `""`。

### 时间复杂度分析：
+ **时间复杂度**：O(n)，其中 `n` 是字符串 `s` 的长度。我们只遍历一次字符串 `s`，右指针和左指针都只会分别移动一次。
+ **空间复杂度**：O(1)，由于 `need` 和 `window` 数组的大小固定（均为 128），空间复杂度是常数级别。



> 更新: 2025-03-24 15:00:11  
> 原文: <https://www.yuque.com/neumx/ko4psh/ddvs765taegu551i>