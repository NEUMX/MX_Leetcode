# 114. 二叉树展开为链表

### 递归思路（ <font style="color:#DF2A3F;">递归遍历左右子树，然后先保存右子树，左子树去右子树，然后遍历到右子树的末尾，给之前保存的那个右子树连接起来</font> ）
### 解题思路
我们需要对树进行修改，使得树的结构变成单链表。这个过程可以通过递归或者迭代来完成。对于每个节点，我们需要做以下操作：

1. **递归**地展开左子树，并将左子树变为链表。
2. **右子树**应该接到左子树展开后的链表之后。
3. **修改当前节点**：
    - 将当前节点的左指针设置为 `null`。
    - 将当前节点的右指针指向左子树展开后的链表。
    - 然后继续处理右子树。

### 递归实现
我们可以使用递归的方法，利用先序遍历的顺序来处理每个节点。具体的步骤是：

+ 对当前节点展开左子树。
+ 保存右子树的引用。
+ 将左子树转为链表，接到当前节点的右指针。
+ 继续处理右子树。

---

```java
public class Solution {
    public void flatten(TreeNode root) {
        // 如果根节点为空，直接返回，不做任何操作
        if (root == null) {
            return;
        }
        
        // 先序遍历，递归展开左子树
        flatten(root.left);
        // 递归展开右子树
        flatten(root.right);
        
        // 保存右子树，以便后续连接使用
        TreeNode tempRight = root.right;
        
        // 将左子树移动到右子树位置
        root.right = root.left;
        // 清空左子树指针
        root.left = null;
        
        // 找到当前右子树的末尾（即最右边的节点）
        TreeNode current = root;
        while (current.right != null) {
            current = current.right;
        }
        
        // 将之前保存的右子树接到当前右子树的末尾
        current.right = tempRight;
    }
}
```

### 代码解析：
1. `**flatten**`** 函数**：这是主函数，输入是二叉树的根节点 `root`。通过递归调用，将整个树展开为链表。
2. **递归处理**：
    - 首先递归处理左子树。
    - 然后递归处理右子树。
    - 将当前节点的右子树接到左子树的末尾。
3. **修改节点指针**：
    - 将当前节点的左指针设置为 `null`。
    - 将当前节点的右指针指向展开后的左子树。
4. **连接右子树**：
    - 找到左子树的最后一个节点（即当前节点的右指针指向的节点）。
    - 将原本的右子树连接到左子树的末尾。

### 时间复杂度和空间复杂度：
+ **时间复杂度**：O(n)，其中 `n` 是二叉树的节点数。每个节点被访问一次，因此时间复杂度是 O(n)。
+ **空间复杂度**：O(h)，其中 `h` 是树的高度。递归调用栈的最大深度是树的高度，最坏情况下是 O(n)，最好的情况下是 O(log n)。



> 更新: 2025-02-21 21:22:08  
> 原文: <https://www.yuque.com/neumx/ko4psh/icou42hs1yxbx23p>