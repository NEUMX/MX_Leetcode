# 153. 寻找旋转排序数组中的最小值

###  解题思路  （<font style="color:#DF2A3F;">利用旋转数组的局部有序性，通过二分查找找到最小值所在的旋转点）</font>
这题是`**left < right**`：

+ 这种写法通常用于 **查找一个特定位置**（通常是一个界限或者峰值等）的问题，避免出现重复检查的情况。
+ **典型场景**：用于寻找区间的最小值或者最大值时，当 `left == right` 时，我们可以确定此时的位置就是答案，因此不再需要多次检查该位置。

### 题目要求在一个 **旋转后的有序数组** 中找到最小值，且时间复杂度必须是 **O(log n)**，这表明我们应该使用 **二分查找** 来高效求解。
### **旋转数组的特点**
1. **数组原本是升序的**，但经过旋转后被分成两部分：
    - 例如 `[4,5,6,7,0,1,2]` 是 `[0,1,2,4,5,6,7]` 旋转后的结果。
    - 其中 `0` 是最小值，它位于**无序的地方**。
2. **最小值的特性**
    - 在未旋转的情况下，数组是完全递增的，最左侧的元素就是最小值。
    - 在旋转之后，最小值出现在 **断点处**，即 **右侧的递增部分的第一个元素**。

### **二分查找思路**
由于数组是部分有序的，我们可以利用 **二分查找**：

1. **初始化 **`**left = 0, right = nums.length - 1**`。
2. **判断 **`**mid**`** 处的值**：
    - **如果 **`**nums[mid] > nums[right]**`：
        * 说明最小值一定在 `mid` 右侧（无序区域）。
        * 移动左指针 `left = mid + 1`。
    - **如果 **`**nums[mid] < nums[right]**`：
        * 说明 `mid` 可能是最小值，或者最小值在 `mid` 左侧（有序区域）。
        * 移动右指针 `right = mid`。
3. **最终 **`**left**`** 指向最小值**。

---

```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;

        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] > nums[right]) {
                left = mid + 1; // 最小值在右侧
            } else {
                right = mid; // 可能是当前mid，也可能在左侧，所以不是mid-1
            }
        }
        
        return nums[left]; // left 指向最小值
    }
}

```

## **复杂度分析**
+ **时间复杂度**：O(log n)，因为每次查找都会减少一半的搜索范围。
+ **空间复杂度**：O(1)，只使用了常数额外空间。



> 更新: 2025-05-26 11:46:40  
> 原文: <https://www.yuque.com/neumx/ko4psh/mgbmnm7b40e9diu3>