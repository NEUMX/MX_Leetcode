# 189. 轮转数组

### 解题思路（<font style="color:#DF2A3F;">k 取模，翻转整个数组，再反转前 k 个，再反转 k 到 n-1</font>）
#### 翻转法的核心思路
1. **对 **`**k**`** 取模：**
    - 如果 `k` 大于数组长度 `n`，则旋转 `k` 步和旋转 `k % n` 步是等效的。因此，我们先对 `k` 进行取模操作，避免不必要的多余循环。
2. **数组翻转：**
    - **翻转整个数组：** 将整个数组的元素顺序逆转。这样一来，原本数组的最后部分就被移到数组的前面。
    - **翻转前 **`**k**`** 个元素：** 这样可以将被旋转到前面的部分恢复成正确的顺序。
    - **翻转剩余的 **`**n - k**`** 个元素：** 这样做将剩余部分恢复成正确的顺序。

通过这种方式，我们仅使用了数组的翻转操作来完成旋转，避免了逐个移动元素，显著提高了效率。

---

```java
class Solution {
    // 主方法，用于将数组向右轮转k个位置
    public void rotate(int[] nums, int k) {
        // 获取数组长度并赋值给变量n
        int n = nums.length;
        // 对k取余，以处理k大于数组长度的情况
        k %= n;
        
        // 翻转整个数组，将数组元素顺序颠倒
        reverse(nums, 0, n - 1);
        
        // 翻转数组前k个元素，将这部分元素恢复到轮转后的正确顺序
        reverse(nums, 0, k - 1);
        
        // 翻转数组剩余的元素，将这部分元素恢复到轮转后的正确顺序
        reverse(nums, k, n - 1);
    }

    // 辅助方法，用于翻转数组指定范围内的元素
    public void reverse(int[] nums, int start, int end) {
        // 使用循环，通过交换两端的元素来翻转指定范围的数组
        while (start < end) {
            // 临时变量，用于交换元素
            int temp = nums[start];
            // 将右侧元素放到左侧
            nums[start] = nums[end];
            // 将左侧元素放到右侧
            nums[end] = temp;
            // 左指针向右移动一位
            start++;
            // 右指针向左移动一位
            end--;
    }}
}

```

#### 时间复杂度
+ **时间复杂度：**
    - 每次翻转操作的时间复杂度是 `O(n)`，总共进行 3 次翻转，所以时间复杂度是 `O(n)`，其中 `n` 是数组的长度。
+ **空间复杂度：**
    - 由于我们在原数组上进行操作，只需要常数空间来交换元素，因此空间复杂度是 **O(1)**。







> 更新: 2025-02-18 22:19:31  
> 原文: <https://www.yuque.com/neumx/ko4psh/tpprgrntzu64ptgv>