# 53. 最大子数组和

### 思路（<font style="color:#DF2A3F;">通过贪心算法，遍历数组时维护当前子数组的最大和，然后更新全局最大和</font>。）
**别忘了还有变形**

**题目要求**  
请你找出一个具有**最大和**的连续子数组（子数组最少包含一个元素）。

### 核心思路
1. **初始设定**
    - 定义 `maxans = nums[0]`，将数组的第一个元素当作最大元素，用来比较。
2. **关键逻辑**
    - **这一行代码非常核心：**

```java
pre = Math.max(pre + x, x);
```

        * 解释：如果前边累加后的值还不如当前元素自身大，那就把前边的累加值全部舍弃，从当前元素本身重新开始累加。

---

```java
class Solution {
    public int maxSubArray(int[] nums) {
        // 初始化变量 pre 为 0，它用来存储当前元素结尾的最大子数组和，相当于前缀和
        int pre = 0;
        // 初始化变量 maxAns 为数组的第一个元素，它用来存储遍历过程中的最大子数组和
        int maxAns = nums[0];
        
        // 遍历数组中的每个元素
        for (int x : nums) {
            // 更新 pre 为当前元素 x 加上之前的最大子数组和（pre）与当前元素 x 本身之间的较大值
            // 这一步是贪心选择，如果之前的最大子数组和是负数，则选择当前元素 x 本身作为新的子数组开始
            pre = Math.max(pre + x, x);
            // 更新 maxAns 为当前已知的最大子数组和（maxAns）与刚刚计算出的最大子数组和（pre）之间的较大值
            // 这一步是动态规划，记录下遍历过程中的最大子数组和
            maxAns = Math.max(maxAns, pre);
        }
        
        // 返回遍历数组后得到的最大子数组和
        return maxAns;
    }
}
```

### 时间复杂度与空间复杂度
#### **时间复杂度**
+ 遍历数组一次，时间复杂度为 **O(n)**。

#### **空间复杂度**
+ 只使用了两个变量 `pre` 和 `maxAns`，空间复杂度为 **O(1)**。

---

## 变形题目： 但是要求返回子数组，而不是返回最大和。   百度考了，要求要求返回子数组  
### 思路
在 前面的基础上，增加子数组的起点记录：

1. **记录当前子数组的起点**：
    - 如果选择了 `nums[i]` 本身作为新的子数组（即 `pre + nums[i] < nums[i]`），则将当前索引 `i` 设为子数组的起点。
    - 否则，继续扩展当前子数组。
2. **更新最大子数组和及其范围**：
    - 当发现更大的子数组和时，记录其起点和终点。

```java
class Solution {
    public int[] maxSubArray(int[] nums) {
        // 如果输入数组为空，直接返回空数组
        if (nums.length == 0) {
            return new int[0];
        }

        // 初始化变量
        int pre = 0; // 当前子数组的最大和
        int maxSum = nums[0]; // 全局最大子数组和，初始化为第一个元素
        int start = 0, end = 0, tempStart = 0; // 子数组的起点、终点和临时起点

        // 遍历数组，更新子数组的最大和以及起止位置
        for (int i = 0; i < nums.length; i++) {
            // 判断是否要重新开始一个新的子数组
            if (pre + nums[i] < nums[i]) {
                // 当前元素比加上前面的和更大，说明应该从当前元素重新开始新的子数组
                pre = nums[i]; // 更新当前子数组的最大和为当前元素
                tempStart = i; // 更新临时起点为当前元素的索引
            } else {
                // 当前元素可以继续扩展当前子数组
                pre += nums[i]; // 更新当前子数组的最大和
            }

            // 如果当前子数组和比全局最大子数组和还大
            if (pre > maxSum) {
                maxSum = pre; // 更新全局最大子数组和
                start = tempStart; // 更新全局最大子数组的起点为当前临时起点
                end = i; // 更新全局最大子数组的终点为当前索引
            }
        }

        // 构造结果子数组
        int[] result = new int[end - start + 1]; // 根据起点和终点计算结果子数组长度
        for (int i = start; i <= end; i++) {
            result[i - start] = nums[i]; // 将原数组的子数组元素拷贝到结果数组
        }

        return result; // 返回最大子数组
    }
}

```



### 时间复杂度与空间复杂度
1. **时间复杂度**：
    - 遍历数组一次，时间复杂度为 **O(n)**。
2. **空间复杂度**：
    - 结果子数组的空间使用为 **O(k)**（`k` 为子数组长度），其余变量使用常数空间。
    - 总空间复杂度为 **O(k)**。



> 更新: 2025-03-24 15:03:53  
> 原文: <https://www.yuque.com/neumx/ko4psh/ia6chyuxey0p5wu8>