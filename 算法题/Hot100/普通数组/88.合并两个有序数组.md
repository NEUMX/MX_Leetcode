# 88. 合并两个有序数组

### 题目解答（三指针，<font style="color:#DF2A3F;">从后往前遍历两个数组，将较大的元素放到 数组 1 的末尾，直到所有元素合并完成。</font>）
### 解题思路
1. **数组结构说明**：
    - `nums1` 的长度已经给定为 `m + n`，其中前 `m` 个元素是有效的，后 `n` 个元素是零，这些零是为合并 `nums2` 中的元素预留的空间。
    - `nums2` 的长度是 `n`。
2. **合并思路**：
    - 由于数组 `nums1` 和 `nums2` 都是有序的，合并时可以从后往前合并，这样可以避免覆盖 `nums1` 中有效元素。
    - 设置三个指针： 
        * `i`：指向 `nums1` 中有效元素的最后一个位置（即 `m - 1`）。
        * `j`：指向 `nums2` 中最后一个元素的位置（即 `n - 1`）。
        * `k`：指向 `nums1` 的最后一个位置（即 `m + n - 1`），这个位置用来填充合并后的元素。
3. **合并过程**：
    - 比较 `nums1[i]` 和 `nums2[j]`，将较大的元素放入 `nums1[k]`，然后相应地移动指针。
    - 如果 `nums2` 的元素先被用完，将 `nums1` 中剩余的元素复制到 `nums1` 中。
    - 如果 `nums1` 的元素先被用完，将 `nums2` 中剩余的元素复制到 `nums1` 中。
4. **时间复杂度**：
    - 时间复杂度是 O(m + n)，因为我们需要遍历 `nums1` 和 `nums2` 的所有元素。
5. **空间复杂度**：
    - 空间复杂度是 O(1)，因为我们是直接在 `nums1` 中进行操作，不需要额外的空间。

### 代码实现
```java
public class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        // i 指向 nums1 中有效元素的最后一个位置
        int i = m - 1;
        // j 指向 nums2 的最后一个元素
        int j = n - 1;
        // k 指向 nums1 的最后一个位置
        int k = m + n - 1;
        
        // 从后往前合并，直到 nums1 或 nums2 中的元素都被处理完
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k] = nums1[i];
                i--;
            } else {
                nums1[k] = nums2[j];
                j--;
            }
            k--;
        }
        
        // 如果 nums2 中还有剩余元素，直接复制到 nums1 中
        while (j >= 0) {
            nums1[k] = nums2[j];
            j--;
            k--;
        }
        
        // 如果 nums1 中有剩余元素，不需要做任何操作，因为它们已经在正确的位置上
    }
}
```

### 运行过程
1. 初始时：
    - `nums1 = [1, 2, 3, 0, 0, 0]`
    - `nums2 = [2, 5, 6]`
    - `m = 3`, `n = 3`
2. 从后往前合并：
    - 比较 `nums1[2]` 和 `nums2[2]`，`nums2[2] = 6` 比较大，放到 `nums1[5]`，然后 `k--`，`j--`。
    - 比较 `nums1[2]` 和 `nums2[1]`，`nums2[1] = 5` 比较大，放到 `nums1[4]`，然后 `k--`，`j--`。
    - 比较 `nums1[2]` 和 `nums2[0]`，`nums1[2] = 3` 比较大，放到 `nums1[3]`，然后 `k--`，`i--`。
    - 比较 `nums1[1]` 和 `nums2[0]`，`nums2[0] = 2` 比较小，放到 `nums1[2]`，然后 `k--`，`j--`。
    - 此时 `nums2` 已经空了，剩余的 `nums1` 元素已经在正确位置。
3. 最终合并后的结果是 `nums1 = [1, 2, 2, 3, 5, 6]`。

### 时间复杂度与空间复杂度分析
+ **时间复杂度**：O(m + n)，我们需要遍历 `nums1` 和 `nums2` 中的所有元素。
+ **空间复杂度**：O(1)，由于是原地合并，不需要额外的存储空间。

这个算法的时间和空间复杂度是最优的。



> 更新: 2025-03-24 15:54:22  
> 原文: <https://www.yuque.com/neumx/ko4psh/zgkkce5sla1m8d5q>