# 64. 最小路径和

### 解题思路（<font style="color:#DF2A3F;">初始化第一行第一列，当前只能从左边或者上边来，选择一个最小的，加上当前 grid[i][j]</font>）
### 动态规划解法：
1. **状态定义**：  
设 `dp[i][j]` 表示从起点 `(0, 0)` 到达位置 `(i, j)` 的最小路径和。
2. **状态转移方程**：
    - 当前位置 `(i, j)` 的最小路径和为：  
`dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])`。  
也就是说，当前位置的最小路径和等于当前格子的值 `grid[i][j]` 加上从上面或左边到达该位置的最小路径和。
3. **边界条件**：
    - 第一行和第一列的路径和只能从一个方向到达，直接累加。
    - 第一行的路径和是从左到右累加，第一列的路径和是从上到下累加。
4. **目标**：  
最终我们要得到 `dp[m-1][n-1]`，即从左上角到右下角的最小路径和。

### 代码实现
### Java 代码
```java
public class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        
        // 创建一个 m x n 的 dp 数组
        int[][] dp = new int[m][n];
        
        // 初始化第一行
        dp[0][0] = grid[0][0];
        for (int j = 1; j < n; j++) {
            dp[0][j] = dp[0][j-1] + grid[0][j];
        }
        
        // 初始化第一列
        for (int i = 1; i < m; i++) {
            dp[i][0] = dp[i-1][0] + grid[i][0];
        }
        
        // 填充 dp 数组
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = grid[i][j] + Math.min(dp[i-1][j], dp[i][j-1]);
            }
        }
        
        // 返回右下角的最小路径和
        return dp[m-1][n-1];
    }
}

```

### 详细解答过程：
1. **初始化**：  
创建一个 `m x n` 的二维数组 `dp`，用于存储从起点到达每个位置的路径数。
2. **边界条件**：
    - 第一行（`dp[0][j]`）和第一列（`dp[i][0]`）的每个位置都只能通过一个方向到达，即只能向右或向下，所以它们的值都为 1。
3. **状态转移**：
    - 对于任意位置 `(i, j)`，其路径数是由上方 `(i-1, j)` 和左方 `(i, j-1)` 的路径数决定的：
        * `dp[i][j] = dp[i-1][j] + dp[i][j-1]`。
4. **返回值**：
    - 最终，返回 `dp[m-1][n-1]`，即到达右下角的不同路径数。

### 时间复杂度：
+ **时间复杂度**：`O(m * n)`，因为我们需要遍历整个 `m x n` 的二维数组。
+ **空间复杂度**：`O(m * n)`，因为我们使用了一个 `m x n` 的数组来存储路径数。



### 


> 更新: 2025-03-02 21:25:08  
> 原文: <https://www.yuque.com/neumx/ko4psh/uar2wtbpp8t1krqx>