# 62. 不同路径

### 解题思路（<font style="color:#DF2A3F;">初始化第一行第一列，当前只能从左边或者上边来</font>）
### 动态规划解法：
1. **状态定义**：  
设 `dp[i][j]` 表示从起点 `(0, 0)` 到达位置 `(i, j)` 的不同路径数。
2. **状态转移方程**：
    - 当前位置 `(i, j)` 的路径数可以由左边 `(i, j-1)` 和上面 `(i-1, j)` 的路径数推导出来。
    - 因此，`dp[i][j] = dp[i-1][j] + dp[i][j-1]`（注意边界情况）。
3. **边界条件**：
    - 第一行和第一列的路径数只能是 1，因为机器人只能沿着边界一直向右或向下走。
4. **目标**：  
最终我们要得到 `dp[m-1][n-1]`，即从左上角到右下角的路径数。

### 解题步骤：
1. 初始化一个 `m x n` 的二维数组 `dp`。
2. 填充边界条件，第一行和第一列的每个元素都设置为 1。
3. 根据状态转移方程填充整个数组。
4. 返回 `dp[m-1][n-1]`。

### 代码实现
### Java 代码
```java
public class Solution {
    public int uniquePaths(int m, int n) {
        // 创建一个 m x n 的 dp 数组
        int[][] dp = new int[m][n];
        
        // 初始化第一列和第一行为 1，因为机器人只能从上方或左方到达这些位置
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n; j++) {
            dp[0][j] = 1;
        }
        
        // 填充剩下的 dp 数组
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        
        // 返回右下角的值，即为从左上角到右下角的不同路径数
        return dp[m-1][n-1];
    }
}

```

### 详细解答过程：
1. **初始化**：  
创建一个 `m x n` 的二维数组 `dp`，用于存储从起点到达每个位置的路径数。
2. **边界条件**：
    - 第一行（`dp[0][j]`）和第一列（`dp[i][0]`）的每个位置都只能通过一个方向到达，即只能向右或向下，所以它们的值都为 1。
3. **状态转移**：
    - 对于任意位置 `(i, j)`，其路径数是由上方 `(i-1, j)` 和左方 `(i, j-1)` 的路径数决定的：
        * `dp[i][j] = dp[i-1][j] + dp[i][j-1]`。
4. **返回值**：
    - 最终，返回 `dp[m-1][n-1]`，即到达右下角的不同路径数。

### 时间复杂度：
+ **时间复杂度**：`O(m * n)`，因为我们需要遍历整个 `m x n` 的二维数组。
+ **空间复杂度**：`O(m * n)`，因为我们使用了一个 `m x n` 的数组来存储路径数。



### 


> 更新: 2025-03-02 21:22:40  
> 原文: <https://www.yuque.com/neumx/ko4psh/imm040y9uod2qk7k>