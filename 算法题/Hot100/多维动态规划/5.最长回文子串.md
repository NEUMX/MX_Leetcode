# 5. 最长回文子串

### 解题思路（使用动态规划，<font style="color:#DF2A3F;">所有长度为 1 的子串（即 </font>`<font style="color:#DF2A3F;">dp[i][i]</font>`<font style="color:#DF2A3F;">）都是回文串，所有长度为 2 的子串，</font>`<font style="color:#DF2A3F;">s[i] == s[i+1]</font>`<font style="color:#DF2A3F;"> 时是回文串，否则不是回文串。大于 2 时，只有当两端字符相等，并且中间子串也是回文的，整个子串才是回文的</font>）
#### 1. **定义状态**：
我们使用一个二维布尔数组 `dp[i][j]` 来表示子串 `s[i...j]` 是否是回文子串。

+ `dp[i][j] = true` 表示 `s[i...j]` 是回文子串。
+ `dp[i][j] = false` 表示 `s[i...j]` 不是回文子串。

#### 2. **状态转移方程**：
+ `dp[i][j] = true` 当且仅当：
    - `s[i] == s[j]`，即子串两端字符相等。
    - `dp[i+1][j-1] == true`，即子串 `s[i+1...j-1]` 是回文子串（这是递归关系）。

也就是说，对于任意 `i` 和 `j`，如果两端字符相等，并且中间的子串是回文的，那么整个子串就是回文的。

#### 3. **初始化**：
+ 所有长度为 1 的子串（即 `dp[i][i]`）都是回文串，因为单个字符是回文。
+ 所有长度为 2 的子串，`s[i] == s[i+1]` 时是回文串，否则不是回文串。

#### 4. **填表**：
从长度为 2 的子串开始，逐步计算所有长度为 `k` 的子串，直到整个字符串的最长子串。我们从小到大逐步填充 `dp` 数组。

#### 5. **最终答案**：
最长回文子串的长度和起始位置可以通过遍历 `dp` 数组来得到。

### 动态规划法的步骤
1. 初始化一个二维布尔数组 `dp`，并初始化长度为 1 的回文串。
2. 从长度为 2 开始，逐步计算更长的回文子串。
3. 在计算过程中，记录下最长的回文子串的长度和起始位置。
4. 最后，返回最长回文子串。

### 代码实现
### Java 代码
```java
public class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        if (n == 0) return "";

        // dp[i][j] 表示子串 s[i...j] 是否是回文串
        boolean[][] dp = new boolean[n][n];
        int maxLen = 1;  // 最长回文子串的长度
        int start = 0;   // 最长回文子串的起始位置

        // 初始化：所有长度为 1 的子串都为回文串
        for (int i = 0; i < n; i++) {
            dp[i][i] = true;
        }

        // 枚举子串长度，从 2 开始
        for (int len = 2; len <= n; len++) {
            for (int i = 0; i <= n - len; i++) {
                int j = i + len - 1;  // 子串的结束位置

                // 判断是否为回文串
                if (s.charAt(i) == s.charAt(j)) {
                    if (len == 2 || dp[i + 1][j - 1]) {
                        dp[i][j] = true;
                        if (len > maxLen) {
                            maxLen = len;
                            start = i;
                        }
                    }
                }
            }
        }

        // 返回最长回文子串
        return s.substring(start, start + maxLen);
    }
}

```

### 代码解析：
1. **初始化 **`**dp**`** 数组**：
    - 我们创建了一个二维布尔数组 `dp`，其大小为 `n x n`，其中 `dp[i][i] = true` 表示 `s[i...i]` 是回文（每个单字符都是回文）。
2. **填充 **`**dp**`** 数组**：
    - 通过两层循环，外层循环遍历所有子串的长度 `len`，从 2 到 `n`。
    - 内层循环遍历每个可能的子串起始位置 `i`，并计算子串结束位置 `j = i + len - 1`。
    - 如果 `s[i] == s[j]` 并且中间的子串 `s[i+1...j-1]` 是回文（即 `dp[i+1][j-1] == true`），那么 `dp[i][j] = true`，即 `s[i...j]` 是回文子串。
3. **记录最长回文子串**：
    - 在每次更新 `dp[i][j]` 为 `true` 时，检查当前回文子串的长度 `len` 是否超过了已记录的最大长度 `maxLen`，如果是，就更新最大长度和起始位置。
4. **返回结果**：
    - 最后，我们通过 `substring(start, start + maxLen)` 来提取最长回文子串。

### 时间复杂度：
+ **时间复杂度**：`O(n^2)`，我们需要填充一个 `n x n` 的 `dp` 数组，并且每次计算都涉及常数时间操作。
+ **空间复杂度**：`O(n^2)`，我们使用了一个 `n x n` 的二维数组来存储子串是否为回文的状态。

## 中心扩展法（时间复杂度 O(n²)  ，空间复杂度只有 O(1)  ）
### 中心扩展法讲解
**中心扩展法** 是一种解决字符串类回文问题的经典方法，特别适用于**最长回文子串**问题。其核心思想是利用回文串的对称性质。

#### 回文串的对称性质
一个回文串是正着读和反着读都相同的字符串。例如，`"aba"` 和 `"racecar"` 都是回文串。

回文串有一个重要的性质：它是以某个“中心”对称的。这个“中心”可以是一个字符（例如 `"aba"` 中的 `b` 是中心，字符串长度为奇数），也可以是两个字符之间（例如 `"abba"` 中的 `bb` 是中心，字符串长度为偶数）。

#### 中心扩展法的核心思想
1. **以每个字符为中心**，尝试扩展回文串。
    - 对于字符串中的每个字符，我们以该字符为中心，向左右扩展，查找所有可能的回文子串。
2. **两种情况的中心**：
    - **奇数长度回文**：回文的中心是一个字符（如 "aba"），例如 `"a"`、`"b"`、`"c"`。
    - **偶数长度回文**：回文的中心是两个字符之间（如 "abba"），例如 `"ab"`、`"bc"`、`"cd"`。
3. **扩展过程**：
    - 对每一个中心位置，我们通过逐渐扩展左右边界来判断是否是回文子串。扩展时，如果左右字符相等，就继续扩展，直到左右字符不再相等或越界。

#### 详细步骤
1. 遍历字符串中的每个字符，作为回文中心。
2. 对于每个字符，尝试扩展：
    - 一次以该字符为中心，扩展查找奇数长度的回文。
    - 一次以该字符和下一个字符之间为中心，扩展查找偶数长度的回文。
3. 对每次扩展得到的回文子串进行比较，保持最大回文子串。

#### 例子
假设字符串是 `"babad"`。

+ **中心扩展法**：
    - 遍历每个字符：
        * 对于第一个字符 `'b'`，我们扩展找回文子串 `bab`（奇数长度回文）。
        * 对于第二个字符 `'a'`，我们扩展找回文子串 `aba`（奇数长度回文）。
        * 对于第三个字符 `'b'`，扩展回文串为 `b` 和 `bb`（偶数长度回文）。
        * 依此类推。

通过这种方式，我们就能够找出 `bab` 和 `aba`，其中 `bab` 是最长的回文子串。

#### 优点
+ **时间复杂度**：O(n²)，因为我们要检查每个字符的扩展情况，最多进行 O(n) 次扩展，每个扩展检查 O(n) 次。
+ **空间复杂度**：O(1)，除了返回的回文子串外，我们只用了常数的额外空间。

#### 实现代码
我们再回顾一下代码，帮助更好理解。

```java
// 此方法用于找出字符串 s 中的最长回文子串
public String longestPalindrome(String s) {
    // 如果输入字符串 s 为空或者长度为 0，直接返回空字符串
    if (s == null || s.length() == 0) return "";

    // 记录最长回文子串的起始位置
    int start = 0;
    // 记录最长回文子串的长度，初始化为 1
    int maxLength = 1;

    // 遍历字符串 s 中的每个字符
    for (int i = 0; i < s.length(); i++) {
        // 以当前字符为中心，向两边扩展，得到奇数长度的回文子串的长度
        int len1 = expandAroundCenter(s, i, i);
        // 以当前字符和下一个字符为中心，向两边扩展，得到偶数长度的回文子串的长度
        int len2 = expandAroundCenter(s, i, i + 1);
        // 取奇数长度和偶数长度回文子串长度的最大值
        int len = Math.max(len1, len2);

        // 如果当前找到的回文子串长度大于之前记录的最大长度
        if (len > maxLength) {
            // 更新最大长度
            maxLength = len;
            // 计算当前最长回文子串的起始位置
            start = i - (len - 1) / 2;
        }
    }

    // 从字符串 s 中截取最长回文子串并返回
    return s.substring(start, start + maxLength);
}

// 此方法用于以 left 和 right 为中心向两边扩展，计算回文子串的长度
private int expandAroundCenter(String s, int left, int right) {
    // 当 left 不越界、right 不越界且左右字符相等时，继续向两边扩展
    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
        // 左指针左移
        left--;
        // 右指针右移
        right++;
    }
    // 返回回文子串的长度
    return right - left - 1;
}    
```

#### 代码解释
1. **longestPalindrome**：遍历字符串的每个字符，分别以字符和字符对之间为中心进行扩展，并保持最长回文子串。
2. **expandAroundCenter**：这个方法负责从中心开始扩展，检查扩展的回文是否有效，并返回回文子串。

#### 复杂度分析
+ **时间复杂度**：O(n²)。对于每个字符，我们最多扩展 n 次，因此总共需要 O(n²) 次比较。
+ **空间复杂度**：O(1)。除了返回的回文子串，我们没有使用额外的空间。

#### 总结
+ 中心扩展法通过每次将字符串的字符当作回文中心向两边扩展来查找回文子串，既简单又高效。
+ 适用于大多数需要处理回文问题的场景，尤其是在空间复杂度较为严格的情况下。

希望这个讲解能帮助你更好地理解中心扩展法！

### 


> 更新: 2025-03-31 23:18:45  
> 原文: <https://www.yuque.com/neumx/ko4psh/puz4kk52o4haauz0>