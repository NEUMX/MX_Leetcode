# 72. 编辑距离

### 解题思路（<font style="color:#DF2A3F;">通过二维动态规划，计算将 word1 前 i 个字符转换为 word2 前 j 个字符的最小操作数，基于字符是否相等选择继承或取插入、删除、替换三种操作的最优解</font>）
#### 动态规划思路
我们定义一个二维数组 `dp[i][j]` 来表示将 `word1` 的前 `i` 个字符转换成 `word2` 的前 `j` 个字符所需要的最少操作数。

#### 递推关系：
1. **插入操作**：如果我们从 `word1[0...i-1]` 转换到 `word2[0...j-1]`，那么插入一个字符相当于 `dp[i][j-1] + 1`，即在 `word1` 的末尾插入 `word2[j-1]`。
2. **删除操作**：如果我们从 `word1[0...i-1]` 转换到 `word2[0...j-1]`，那么删除一个字符相当于 `dp[i-1][j] + 1`，即删除 `word1[i-1]`。
3. **替换操作**：如果 `word1[i-1] != word2[j-1]`，那么替换操作是将 `word1[i-1]` 替换为 `word2[j-1]`，即 `dp[i-1][j-1] + 1`。
4. **字符匹配**：如果 `word1[i-1] == word2[j-1]`，那么无需操作，直接继承 `dp[i-1][j-1]`。

#### 边界条件：
+ `dp[0][j] = j`：表示将空字符串 `word1` 转换为 `word2[0...j-1]` 需要 `j` 次插入操作。
+ `dp[i][0] = i`：表示将 `word1[0...i-1]` 转换为空字符串 `word2` 需要 `i` 次删除操作。

### 代码实现
### Java 代码
```java
public class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();

        // dp[i][j] 表示将 word1[0...i-1] 转换为 word2[0...j-1] 的最小操作数
        int[][] dp = new int[m + 1][n + 1];

        // 初始化 dp 数组的边界条件
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;  // 将 word1[0...i-1] 转换为空字符串需要 i 次删除
        }
        for (int j = 0; j <= n; j++) {
            dp[0][j] = j;  // 将空字符串转换为 word2[0...j-1] 需要 j 次插入
        }

        // 填充 dp 数组
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    // 如果字符相等，则继承左上角的值
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    // 否则，取插入、删除、替换三种操作的最小值
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                }
            }
        }

        // dp[m][n] 就是将 word1 转换为 word2 所需的最少操作数
        return dp[m][n];
    }
}

```

### 代码解析
1. **初始化 **`**dp**`** 数组**：
    - `dp[0][j] = j`：将空字符串 `word1` 转换为 `word2[0...j-1]` 需要 `j` 次插入。
    - `dp[i][0] = i`：将 `word1[0...i-1]` 转换为空字符串 `word2` 需要 `i` 次删除。
2. **填充 **`**dp**`** 数组**：
    - 当 `word1[i-1] == word2[j-1]` 时，`dp[i][j] = dp[i-1][j-1]`，因为不需要操作。
    - 当 `word1[i-1] != word2[j-1]` 时，取三种操作的最小值：
        * 插入操作：`dp[i][j-1] + 1`，即在 `word1` 中插入一个字符使得 `word1[0...i-1]` 转换为 `word2[0...j-1]`。
        * 删除操作：`dp[i-1][j] + 1`，即删除 `word1[i-1]` 字符。
        * 替换操作：`dp[i-1][j-1] + 1`，即将 `word1[i-1]` 替换为 `word2[j-1]`。
3. **返回结果**：
    - 最终结果存储在 `dp[m][n]`，即将 `word1[0...m-1]` 转换为 `word2[0...n-1]` 所需的最小操作数。

### 时间复杂度和空间复杂度
+ **时间复杂度**：`O(m * n)`，我们需要填充一个大小为 `m x n` 的二维数组 `dp`，其中 `m` 和 `n` 分别是 `word1` 和 `word2` 的长度。
+ **空间复杂度**：`O(m * n)`，我们使用了一个 `m x n` 的二维数组来存储中间计算结果。



### 


> 更新: 2025-03-03 23:10:06  
> 原文: <https://www.yuque.com/neumx/ko4psh/taavnugorglmwn5t>